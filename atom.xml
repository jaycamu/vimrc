<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jaycamu.github.io/x-knowledge/</id>
    <title>x-kownledge</title>
    <updated>2019-10-16T04:54:03.790Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jaycamu.github.io/x-knowledge/"/>
    <link rel="self" href="https://jaycamu.github.io/x-knowledge//atom.xml"/>
    <subtitle>知止而后有定</subtitle>
    <logo>https://jaycamu.github.io/x-knowledge//images/avatar.png</logo>
    <icon>https://jaycamu.github.io/x-knowledge//favicon.ico</icon>
    <rights>All rights reserved 2019, x-kownledge</rights>
    <entry>
        <title type="html"><![CDATA[冬吴相对论读书笔记]]></title>
        <id>https://jaycamu.github.io/x-knowledge//post/dong-wu-xiang-dui-lun-du-shu-bi-ji</id>
        <link href="https://jaycamu.github.io/x-knowledge//post/dong-wu-xiang-dui-lun-du-shu-bi-ji">
        </link>
        <updated>2019-10-16T04:38:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="002-专注的幸福">002 专注的幸福</h1>
<ul>
<li>专注不是只做一件事，而是把这个事本质弄清楚，看起来做各种不同的事情，其实做的一件事情。</li>
</ul>
<h1 id="005-博珈梵歌与印度式管理">005 博珈梵歌与印度式管理</h1>
<ul>
<li>成本控制：把一个事情分解到很细很细，每个细节都很专注的负责，关键部分由高手负责。</li>
</ul>
<h1 id="007-轻公司与重公司">007 “轻”公司与“重”公司</h1>
<ul>
<li>资产是轻资产，它的产品是无重化。医疗器械销售公司后来做成了医疗系统解决方法。旅游行业是和谁一起去玩，房地产行业是和谁住一个社区。</li>
</ul>
<h1 id="009-贪嗔痴慢疑">009 贪嗔痴慢疑</h1>
<ul>
<li>贪不限制自己的欲望</li>
<li>嗔这是你的那是我的较真</li>
<li>痴把自己的想法用到别人身上</li>
<li>慢怠慢、不敏感、自我中心，对别人不感兴趣</li>
<li>疑怀疑，自我实现的寓言，怀疑成真</li>
</ul>
<h1 id="010-社区化的价值">010 社区化的价值</h1>
<ul>
<li>读书MBA或者EMBA是为了认识人，车友会也是</li>
<li>贴吧、facebook、myspace</li>
</ul>
<h1 id="019-快公司与慢公司">019 “快”公司与“慢”公司</h1>
<ul>
<li>大型卖场都是一个经融公司，账期的时候可以利用上游的钱来做其他事情，现在京东、亚马逊之类的都是这样，可以投资自己上游，同时绑架上游。</li>
</ul>
<h1 id="021中国汽车业海外并购的机遇与挑战">021中国汽车业海外并购的机遇与挑战</h1>
<ul>
<li>并购过程需要弄清楚对方的内部结构，雇佣前员工。</li>
<li>并购了一个过时的业务，看清楚产业格局，就跟后面说的择业标准一样。化油器投资、录像机投资，CRT电视、柯达胶片、整个产业不这样玩了，全部打水漂。英特尔转型芯片放弃存储器业务，电动车产业。</li>
</ul>
<h1 id="022警惕信用卡危机">022警惕信用卡危机</h1>
<ul>
<li>因为信用卡实际上是一种现代消费里的可以说是一种阴谋了，暂缓你的支付痛苦，在很多场合都可以见到。超市，包括现在蚂蚁花呗等一系列经融付款方式，就是让你花出去出去容易。</li>
</ul>
<h1 id="024富豪作家的商业启示">024富豪作家的商业启示</h1>
<ul>
<li>每个人每个公司做自己核心业务，其他东西外包给更擅长的公司。现在媒体都是内容为王，传播渠道相对简单。</li>
</ul>
<h1 id="029企业如何过冬">029企业如何过冬</h1>
<ul>
<li>每个人都有不同的阶段，在年轻的时候各种资产比较轻，就算失败也损失很小，大公司资产比较重，需要少动聚精会神。</li>
</ul>
<h1 id="028求职与招聘的两难境地">028求职与招聘的两难境地</h1>
<ul>
<li>英语教育的问题是教我们太多这个语法什么，掌握一门语言是掌握它是怎么用的。</li>
<li>学校教学生首先内容和方向错了，另外一个学生的主动性差。高手在民间，都是有兴趣，耳濡目染自学的。</li>
<li>就业想好自己想干嘛，然后根据想做的事情定制自己的能力，提高自己的学习力和核心竞争力。</li>
</ul>
<h1 id="031如果苹果没有了乔布斯">031如果苹果没有了乔布斯</h1>
<ul>
<li>乔布斯发现用技术是为了解决问题，然后让别人感觉不到技术这个才会推广开，这点上公司内部软件技术框架还是需要做到好用才能推广开。</li>
<li>字体除了表达文字的意思还有审美享受，工业设计也走这个路线，需要发现一些东西的附加值让别人看不见的。</li>
<li>开始是懂技术的导演，后来是懂艺术的导演，CEO也一样不懂技术。</li>
</ul>
<h1 id="033柔道战略">033柔道战略</h1>
<ul>
<li>移动法则：大企业灵活性差，小企业变化速度快，找到一个新的方式
<ul>
<li>西红柿笔跟西红柿酱</li>
<li>七天连锁提供上网服务</li>
</ul>
</li>
<li>平衡法则：动机不对称
<ul>
<li>狮子和兔子：一个为了饭，一个为了命</li>
</ul>
</li>
<li>杠杆接力：借力打力
<ul>
<li>火烧连船</li>
</ul>
</li>
</ul>
<h1 id="034危机下的商机">034危机下的商机</h1>
<ul>
<li>在环境比较差的时候，投资自己，停下来检修一下，把所有东西剥离之后你还剩下什么，这样一想之后就发现自己还真的没有什么能力和人脉。</li>
</ul>
<h1 id="039关键零售">039关键零售</h1>
<ul>
<li>找到决策者一对一解决。举例说明：把管理学院的院长搞定，他会带来一系列后续人脉。撬动关键人物杠杆，利用这个造成一个小引爆点，然后连锁反应。《黄帝内经》聚精会神。</li>
</ul>
<h1 id="040好消息坏消息">040好消息坏消息</h1>
<ul>
<li>好消息慢慢说，坏消息一次说。</li>
<li>判断事物的时候，经常不客观的，因为自己已经很多有定数了。</li>
<li>屡战屡败----&gt;屡败屡战</li>
<li>信心和信任很重要，特别遇到问题的时候，对于小孩子做不好要有信心和信任，同时给予鼓励，会正向发展。</li>
<li>树立正确的价值观的意思是正向看待事物。</li>
</ul>
<h1 id="043汽车网销的背后">043汽车网销的背后</h1>
<ul>
<li>切换危机：当一个东西身边很多人在用的时候，自然形成一个压力，导致切换。切换危机才是引爆点，大哥大、苹果手机。</li>
</ul>
<h1 id="046并购与婚姻">046并购与婚姻</h1>
<ul>
<li>能够提高满意的方法就是降低期望值，对于婚姻和儿童的教育。</li>
</ul>
<h1 id="048好运气坏运气">048好运气坏运气</h1>
<ul>
<li>运气比较好的人思考方式不一样，他们想事情的时候，总是想到积极的一面。</li>
<li>想要过什么样的生活，就需要把这个生活具象化，越具体成功的希望越大。</li>
<li>心理雷达，当你注意一件事情的时候，发现突然这个事情多了很多，孕妇，车子同样的牌子，这个因为你平时是过滤掉的。</li>
<li>对于小孩子教育方面，也是应该鼓励为主，让小孩子被你说成是那样的。</li>
<li>信心比黄金还宝贵。</li>
</ul>
<h1 id="049奢侈品陷阱">049奢侈品陷阱</h1>
<ul>
<li>人们为了一种想象的特权去买单。</li>
</ul>
<h1 id="050帕金森法则">050帕金森法则</h1>
<ul>
<li>“无事”才“生非”，人太多就出现了工作的舞蹈，看起来在工作，其实是表演工作。</li>
<li>政治学理论，吴伯凡：这马基亚维利，一个意大利的政治学家，这里头讲了很多让人毛骨悚然的一些权术。其中有一个权术呢，是什么？当你遇到危机的时候，比如说一群狗向你扑来的时候，你就扔一块肉让那些狗抢那块肉，然后你就脱身了。当你的国家发生内乱的时候，你就外面找个敌人，哎，大家就都去对付外面的敌人了。</li>
<li>提拔一个人的时候，因为那个人技术好，但是不一定适合管理，两个方法培训管理技能，或者走专家路线。</li>
</ul>
<h1 id="055创业的逻辑">055创业的逻辑</h1>
<ul>
<li>为什么？还是需要创造价值。撇开钱你还想干的事情。</li>
<li>领导者两个特点：方向感和驱动力。</li>
<li>领导者做对事情追求责任，管理者做好事情关心权力。</li>
</ul>
<h1 id="059变味的星巴克">059变味的星巴克</h1>
<ul>
<li>从卖咖啡豆变成卖咖啡体验，取名就定位了目标人群。</li>
<li>员工能够共享成果，认同企业，点对点扩展，开好一家店在开一家。只有足够满足需求的合格员工才能考虑扩张。</li>
<li>后来资本原因降低的定位，那么就引来无数的竞争。</li>
</ul>
<h1 id="061商人为什么要学哲学">061商人为什么要学哲学</h1>
<ul>
<li>《道德经》：天下皆知美之为美也，斯恶也。大家都知道这个东西是美的时候，那么这个东西一定会变坏。</li>
<li>《黄帝内经》：痛则不通，通则不痛。企业内部沟通问题。</li>
</ul>
<h1 id="062解套未知的自己">062解套未知的自己</h1>
<ul>
<li>卢梭说：人，生而自由，但无时不在枷锁之中。</li>
<li>彼得·圣吉的。他这里头讲的一个心智模式呢，就是说我们在行为，我们在表达的时候暗中遵循的，但我们不以为意的那一个套路，叫心智模式。</li>
<li>本我，自我，超我：马，马车夫，客人</li>
</ul>
<h1 id="063快乐的日本制造">063快乐的日本制造</h1>
<ul>
<li>核心竞争力就是让别人干瞪眼的能力，就是把所有秘密都告诉你，你还是学不会，比如王羲之的字。</li>
<li>日本重要按照要求种植，高价采购，把品质差的还原给土地，品质高的古法炮制。</li>
<li>实际上你反过来看，日本产品的竞争力，实际上它恰恰是来自于这种我们刚才提到的那种道。什么叫道呢？用庖丁的说法啊，“至于道，而进乎技。”就是通过那种精纯的技艺来达到道的这种境界。那么我们在前面节目里头已经提到过，日本文化当中有这么一种特性，不管是多么平常的一件事情，或者是一个平常之物，甚至是比较低贱的事情，只要你全情地投入，以一种仪式般的那种氛围那种心态进入它，去做这件事情的时候，他就能达到一种境界。日本人把它称为“道”。</li>
</ul>
<h1 id="067-3g的误区">067 3G的误区</h1>
<ul>
<li>创新生态系统，如果没有生态系统是做不成，农民买高级车，没有公路和汽油，IPAD类似产品在更早的时候其他配套还不好的时候。</li>
<li>好技术不等于好产品，创新不仅仅是技术上创新更多的时候是创造新的价值。爱迪生其实是把电灯从实验室弄到生活中，先把配套解决了。</li>
<li>好的业务或者产品需要有切换危机，另一个是切换成本。</li>
<li>ANBC分析工具
<ul>
<li>N-Need需求：真正的需求是什么，是不是必须的。</li>
<li>A-Approach手段：满足需求的手段。</li>
<li>B-Benefits per Costs单位成本收益：费用和成本。</li>
<li>C-Competition and the alternatives竞争：被代替。</li>
</ul>
</li>
</ul>
<h1 id="068-谦卦之谦">068 谦卦之“谦”</h1>
<ul>
<li>虚怀若谷，空谷藏峰，吴伯凡：嗯，“谦”！我们普通的人理解“谦”就是谦卑、就是低下、就是主动地去示弱嘛！就是让别人显得高，自己显得低。这是普通的对“谦”的理解，是吧？但是呢这个“谦卦”它不是这样的，不仅仅是一味的低下，它叫“空谷……”它比地面还要低，那是空谷，但是空谷里头矗立着一个山峰，你要站在这个空谷边上的时候，才能看到里头有一座峻峭的山峰。简单的说它是不显山不露水，但是山还是存在的。所以呢有人呢就是把它描述成：卑者为上；亢者为下。我们说“不卑不亢”，是吧？它是卑者为上；亢者为下。他的那种退避为表，征伐为里—就是进取为里，“无往不平形于外，高山仰止运其内”。</li>
<li>好的领导者敢于说出我不懂。</li>
</ul>
<h1 id="069社会资本的价值">069社会资本的价值</h1>
<ul>
<li>融资最大的障碍是抵押。</li>
<li>农村随礼是最早的融资方式，大家都是熟人社会，不还的成本很高，大城市陌生人社会，带来很多信用成本很低。</li>
<li>一个人的社会信用，在你失败的时候，还有多少人肯借钱给你。</li>
</ul>
<h1 id="070不抱怨的世界">070不抱怨的世界</h1>
<ul>
<li>那抱怨的本质是什么呢？抱怨的本质其实你可以往里面挖掘，除了不服人之外，是我们在内心对对方有一种天然的期望，而这种期望对方也不知道，甚至有的时候连自己都不清楚，我对他有那样明确的期望，所以很多时候抱怨和冲突的本质来自于彼此没有达成一种所谓的共识。</li>
<li>恨铁不成钢，我觉得你是钢，但是结果你成了铁。</li>
<li>克己，首先要克己回归礼。所谓礼，其实就是规则、就是界线。所谓己，就是小我，就是自以为所有地方都认为是自己地盘的，这样一个小我。</li>
</ul>
<h1 id="071小时的胶片">071小时的胶片</h1>
<ul>
<li>低端破坏，产品开始很不成熟，但是不断改进之后某一天成了主流，塑料胶片替代玻璃胶片。</li>
<li>刀片模式：就是卖耗材。</li>
<li>在为企业创新不足，在野企业是生死攸关的问题。</li>
</ul>
<h1 id="072关爱创造价值">072关爱创造价值</h1>
<ul>
<li>cardinal health做了医院的医院，服务创造的系统，收集数据分析，然后统一调配资源（器械、医生）。</li>
<li>在服务过程中发现客户的痛点或者潜在的需求。</li>
<li>做平台提供各种资源给注册药剂师开店。</li>
</ul>
<h1 id="073不丹式幸福">073不丹式幸福</h1>
<ul>
<li>现在的经济最终变成一种竞争性的经济，就是你和我之间，我们感受到那种贫困感，人人都觉得没有钱。有一篇文章是一个经济学讲的，说如果你用金钱来衡量你的幸福，当然这种方式比较通俗易懂也容易操作，但是它麻烦就在于总有人比你更有钱。所以呢，任何人会感觉到自己是一个贫困者，所以这里头引入一个概念呢，叫相对贫困感和绝对贫困感。现代人的贫困感，不是来自于绝对贫困感。那什么叫绝对贫困感？就是饥寒交迫，上无片瓦下无立足插针之地，这叫绝对贫困感。但是呢，现代人，你有这种绝对贫困感的人越来越少了，当然还有比如说在非洲，但是呢很多地方，这种绝对贫困感是没有。</li>
<li>现代人的贫困来自邻居和身边熟悉的人的眼光。</li>
</ul>
<h1 id="074有道德的财富">074有道德的财富</h1>
<ul>
<li>营销的手段，用他人的眼光，用邻居来压迫你，用你的年金来压迫你，用你的同事来压迫你，使得你自己感觉到的就是贫困。那么为了摆脱这种贫困，你要赎回这种幸福感，你的幸福感已经被它给拿走了，压在它那了，你要赎，赎就要用你的钱来赎，所以你整体的感觉是不幸福感，是占据了我们生活的大部分时间。</li>
<li>有一个哲学家叫瑟勒的说过，当你攻击一种价值体系的时候，实际上背后是一种怨恨抑或嫉妒，你要摧毁这个价值体系。所以别人会说，你在攻击现在的这个财富逻辑，是因为你被这个财富逻辑给抛弃了，所以你心里对这种财富逻辑是怨恨的，所以别人就会认为你是一个失败者，是一个游离于这个社会之外的一个人。</li>
</ul>
<h1 id="076错位的教育">076错位的教育</h1>
<ul>
<li>《新概念英语》序言里面说了解一门语言是如何运行的和与如何使用完全是两码事。</li>
</ul>
<h1 id="077真相乍现的时刻">077真相乍现的时刻</h1>
<ul>
<li>看一个大企业是否盈利，直接可以看看员工的状态。</li>
<li>能够把企业的事情当自己的事情。</li>
</ul>
<h1 id="079仆人理论">079仆人理论</h1>
<ul>
<li>产品的特点呢，是生产过程跟消费过程是分离的；服务呢是生产过程跟消费过程同步的。</li>
<li>现代服务业，另外一个说法叫生产型服务业，就是在生存过程当中提供服务，比如说：咨询、财务管理，是吧？他都是带有生产性的。传统服务业是消费型的。</li>
<li>中国人对仆人不认可，缺乏社会的尊重和认可，自己也不认可。</li>
<li>在一个好的公司里头，你总能发现这样的人，发现他好多事情，他都事先想到了，他在一个不被人注意的地方在默默的做一些事情的，暗中就在支撑整个的运营系统，实际上这样的人才是真正的领导者。做好服务人别人离不开你。</li>
<li>老师想表现自己是美女的一般都不是，同理其他老是想表现自己的能力肯定不是。</li>
</ul>
<h1 id="082创业童子功">082创业童子功</h1>
<ul>
<li>小孩卖干货让客户自己称，1建立信任；2称的过程，信任之后就是同盟。</li>
<li>送报纸的时候发现客户不在家，提供了把报纸放后门的服务，雨天还给包好。双赢。</li>
<li>咖啡馆门口卖报纸谈判，主要还是先给老板利益，说客人没有报纸不进来，同时社区派送的时候免费给他加上优惠券，满足了别人之后满足了自己，能够在咖啡馆卖报纸。</li>
<li>遇到问题的时候看好的方面，惩罚服务养老院，发现报纸不能及时送到客户手上，提供解决方案，增加了订单。</li>
<li>遇到任何困难都是常态需要坚持，热爱。</li>
</ul>
<h1 id="083免费的奥秘">083免费的奥秘</h1>
<ul>
<li>性是神圣的，因为交易而变的an脏。</li>
<li>刚性需求。所谓刚性需求，就是它不随你价格的涨跌，而影响它的需求。</li>
<li>安德森的解释叫“交叉补偿”。你好像是一个免费的东西，但是你可以通过另外的方式，转移支付的方式、交叉补偿的方式，还是能够把这个成本和利润拿回来。天下没有免费的午餐，只不过看是谁帮你买单。</li>
<li>知识经济的特点，知识能够点石成金，知识还能够产生新的知识。</li>
<li>看看首富是干什么，能体现出现国家行业格局。</li>
<li>我们从《水与钻石的悖论》讲到了免费。现在就清楚了，为什么会出现免费？是因为作为人类财富的基础发生了变化。过去是土地，现在是知识。不是全部的财富，很多财富都是跟知识有关的，而知识的特性就在于它可以不断的增值。这样就意味着，因为知识而产生的产品和物质会越来越丰富，有可能就免费像空气一样的非常重要但是不值钱啦。<strong>物以稀为贵</strong></li>
<li>免费模式
<ul>
<li>比如刀片模式，就是产品本身很便宜，卖耗材。</li>
<li>Windows盗版在中国正好培养的市场。</li>
<li>游戏是免费，道具或者特权收费。</li>
</ul>
</li>
<li>嫉妒对比来自于差不多水平的人才会对比。</li>
<li>信息大爆发的时代，提供信息服务也是可以的，比如百度，另外什么值得买模式。</li>
</ul>
<h1 id="086无所事事的忙碌">086无所事事的忙碌</h1>
<ul>
<li>员工浪费时间主要是目标不明确。</li>
<li>效率和效果，没有目标的行为往往是有效率没有效果，表面上看起来很忙，其实是碌碌无为。</li>
<li>卓有成效
<ul>
<li>善于利用时间。</li>
<li>关注你对外界的贡献是什么。</li>
<li>如何利用别人的长处。</li>
<li>集中精力要是优先。</li>
<li>有效的决策。</li>
</ul>
</li>
<li>人最终的幸福来自于内心的充实。</li>
</ul>
<h1 id="089领导与领导力">089领导与领导力</h1>
<ul>
<li>领导者常常谋求权利，应该谋求影响力。</li>
<li>领导是任命的，领导力是自己赢得的。</li>
<li>领导力，方向感需要很强，有责任自然成为了领导。</li>
</ul>
<h1 id="091量子思维">091量子思维</h1>
<ul>
<li>症状解和杠杆解，四两拨千斤需要根据事物发展规律找到那个点
<ul>
<li>轮船转向用舵不用人</li>
<li>因势利导、治理、庖丁解牛</li>
</ul>
</li>
<li>把合适的人放在合适的位置。</li>
<li>急中生智、定能生慧。智看到了事物的不同，慧看到了事物相同。</li>
<li>修炼，有时候的时候能够感受到水喝下去的过程，洗手的过程。全然接受没有烦恼。烦恼是对于过去的悔恨和将来的恐惧。</li>
</ul>
<h1 id="093知人善用">093知人善用</h1>
<ul>
<li>承认对方有缺点，包容他的短，发挥它的长处。</li>
<li>我们在跟人相处在管理别人的时候一定要注意如何看到别人的长处，让他去干跟这种长处相匹配的工作，而不是在不停的挑他的短处，然后还让他去干一件已经知道他不胜任的事情，这样就是一个很荒诞的游戏。很多的管理的低效率、低效果都是这样出来的，试图去改变人，实际上是一件很愚蠢的事情。</li>
<li>同样在教育小孩的时候，学的会但是教不会。</li>
<li>人是很难改变的。</li>
</ul>
<h1 id="094要事优先">094要事优先</h1>
<ul>
<li>要事优先很重要，但是正确的决策更重要。</li>
<li>怎么样的心智模式有助于正确判断， 一个事情太顺利肯定有问题。大家都一致的判断需要缓冲一下在决定。</li>
<li>小人同而不和，君子和而不同。包容不同意见，然后从中看到某种信号，而不是一惊一乍听风就是雨。</li>
</ul>
<h1 id="095积极的沉默">095积极的沉默</h1>
<ul>
<li>读书给小孩子听，不允许打断，他不懂还坚持听，培养的倾听的能力，慢慢思考，听多了就懂了。</li>
<li>缺乏倾听能力的人，一辈子成就有限。倾听有服从力。</li>
<li>刚才呢和老吴啊我们俩聊到一个话题，就是说如果一个人或者一个小孩子在童年甚至是幼年的时候，被迫或者是有幸的接受了一种倾听的训练，那么对于这个人来说呢，给他带来的是一个人生巨大的财富。我从这个地方呢我想起一个事儿，如果一个女孩子面对两个男孩子，一个男孩子你说到一半他已经有很多观点了，啊，你这个对或者不对，然后加以评注。另外一个人呢，他听你把话说完，然后隔了一秒钟之后才会问你一个问题，你会觉得哪一个比较有吸引力？</li>
<li>《菜根谭》里有一句话说：“觉人之诈，而不形于色，此中有无限乐趣”。就是说当你听到别人在骗你的时候啊，一点都不反应出来，这里头有无限的乐趣。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TEE学习笔记]]></title>
        <id>https://jaycamu.github.io/x-knowledge//post/tee-xue-xi-bi-ji</id>
        <link href="https://jaycamu.github.io/x-knowledge//post/tee-xue-xi-bi-ji">
        </link>
        <updated>2019-06-24T11:13:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="系统介绍">系统介绍</h1>
<p>如果系统芯片支持TrustZone技术且支持TEE，那么TEE将在系统中提供一个安全的运行环境，用于保护系统中的重要数据和安全操作。通常一个完成的系统除了有bootloader和kernel之外还需要有TEE OS。系统启动的时候使用secure boot功能来保护整个系统的image不被恶意篡改。OP-TEE是借助TrustZone技术实现的一种TEE方案。而TEE又属于整个系统中的一个部分，可以看作是与linux kernel同一个层面。</p>
<h1 id="trustzone硬件框架">TrustZone硬件框架</h1>
<p>TrustZone的技术是为了提高系统的安全性而提出的。而对做到对外部资源和内存资源的硬件隔离就是TrustZone的核心。这些硬件隔离包括：中断隔离，片上RAM和ROM的隔离，片外RAM和ROM的隔离，外围设备的硬件隔离，外部RAM和ROM的隔离。</p>
<p>为实现硬件层面的各种隔离就需要对整个系统的硬件和处理器核做出相应的扩展。这些扩展包括对处理器core的虚拟化实现也即将AMR core的运行状态分为了secure world态和non-secure world态。对总线的扩展，增加安全位读写信号线。对MMU的扩展，增加页表的安全位, 对cache的扩展，增加安全位。以及其他外围组件进行了相应的扩展，提供安全操作权限控制和安全操作信号。</p>
<h2 id="处理器核">处理器核</h2>
<p>在支持TrustZone技术的微处理器中，AMR实现了对cortex的虚拟化，将每个物理的处理器虚拟化成两个虚拟核，一个为安全核，一个普通安全核，也就是一个物理核存在secure wrold态和normal world态。为实现一个物理核上的两种状态的切换，ARM增加了一个monitor模式来实现处理器核两种状态的切换。关于微处理器核的状态切换和划分是通过设置CP15中的SCR寄存器来实现的。secure world和normal world的关系如下图所示。关于normal world与secure world之间的切换过程请参考3.3节。</p>
<h2 id="cache和mmu">cache和mmu</h2>
<p>在支持trustzone的soc上，会对MMU进行虚拟化，使得normal world和secure world都具有完全独立的一份TTBR0， TTBR1，TTBCR。也就是每个世界都具有单独的MMU页表。存放在MMU中的每一条页表描述符都会包含一个NS位来表示被映射的内存是属于安全内存还是非安全内存。虚拟化的MMU共享TLB，同样在TLB中的每一项也同样会打上NS标记，只不过该标记是用来表示该条转换是normal  world转化的还是secure world的转化。</p>
<p>cache也是共享的同样也做了扩展，在cache中的每一项都会按照normal world和secure world的状态打上对应的tag，这就能实现在不同的world下面，处理器只要属性自己world的cache就可以了。</p>
<h1 id="op-tee软件框架">OP-TEE软件框架</h1>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdn.net/20170523113635511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></figure>
<h1 id="tee-os">TEE OS</h1>
<h2 id="系统移植">系统移植</h2>
<h3 id="plat-gx">plat-gx</h3>
<ul>
<li>增加一个目录</li>
</ul>
<pre><code class="language-C">core/arch/arm/plat-gx
├── conf.mk                   //编译makefile配置
├── gx_core_pos.S
├── kern.ld.S                 //链接脚本
├── link.mk
├── main.c                    //平台初始化包括uart，中断控制器
├── platform_config.h         //平台内存、时钟、基地址配置
├── plat_init.S
└── sub.mk

</code></pre>
<h3 id="内存规划配置">内存规划配置</h3>
<ul>
<li>platform_config.h</li>
</ul>
<pre><code class="language-C"> 28 #ifndef PLATFORM_CONFIG_H
 29 #define PLATFORM_CONFIG_H
 30
 31 /* Make stacks aligned to data cache line length */
 32 #define STACK_ALIGNMENT           64
 33
 34 /* 16550 UART */
 35 #define CONSOLE_UART_BASE      0x82804000 /* UART0 */
 36 #define CONSOLE_BAUDRATE       115200
 37 #define CONSOLE_UART_CLK_IN_HZ 30000000
 38
 39 #define GIC_BASE               0xA2000000
 40 #define GICC_OFFSET            0x2000
 41 #define GICD_OFFSET            0x1000
 42
 43 #define CNTFRQ                 27000000
 44
 45 #define DRAM0_BASE             0x00000000
 46 #define DRAM0_SIZE             0x10000000
 47
 48 #define TZDRAM_SIZE            (32 * 1024 * 1024)//optee总内存大小
 49 #define CFG_SHMEM_START        (DRAM0_BASE + DRAM0_SIZE - TZDRAM_SIZE)
 50 #define CFG_SHMEM_SIZE         (4 * 1024 * 1024)//共享内存大小
 51
 52 #define TZDRAM_BASE            (CFG_SHMEM_START + CFG_SHMEM_SIZE)//optee的运行地址
 53
 54 #define CFG_TEE_CORE_NB_CORE   (2)
 55 #define CFG_TEE_RAM_VA_SIZE    (4 * 1024 * 1024)
 56 #define CFG_TEE_LOAD_ADDR      (TZDRAM_BASE + 0x20000)//ELF运行地址
 57
 58 #define CFG_TEE_RAM_PH_SIZE    CFG_TEE_RAM_VA_SIZE
 59 #define CFG_TEE_RAM_START      TZDRAM_BASE
 60
 61 #define CFG_TA_RAM_START       ROUNDUP((TZDRAM_BASE + CFG_TEE_RAM_VA_SIZE), CORE_MMU_DEVICE_SIZE)
 62
 63 # define CFG_TA_RAM_SIZE      (16 * 1024 * 1024)
 64
 65 #endif /* PLATFORM_CONFIG_H */
</code></pre>
<h3 id="编译">编译</h3>
<ul>
<li>conf.mk</li>
<li>make PLATFORM=gx</li>
</ul>
<pre><code>  1 PLATFORM_FLAVOR ?= SIRIUS
  2
  3 include core/arch/arm/cpu/cortex-a7.mk
  4
  5 core_arm32-platform-aflags▸ += -mfpu=neon
  6
  7 $(call force,CFG_8250_UART,y)
  8 $(call force,CFG_GENERIC_BOOT,y)
  9 $(call force,CFG_PM_STUBS,y)
 10 $(call force,CFG_SECURE_TIME_SOURCE_CNTPCT,y)
 11 $(call force,CFG_WITH_ARM_TRUSTED_FW,n)
 12 #$(call force,CFG_NS_ENTRY_ADDR, 0x10008000)
 13 #$(call force,CFG_DT_ADDR, 0x13ffc000)
 14 $(call force,CFG_GIC,y)
 15 $(call force,CFG_DT,y)
 16 $(call force,CFG_BOOT_SECONDARY_REQUEST,y)
 17 $(call force,CFG_ARM32_core,y)
 18 $(call force,CFG_TEE_PTA_DEVICE,y)
 19
 20 ta-targets = ta_arm32
 21
 22 CFG_NUM_THREADS ?= 4
 23 CFG_CRYPTO_WITH_CE ?= n
 24 CFG_WITH_STACK_CANARIES ?= y
 25 CFG_TEE_CORE_EMBED_INTERNAL_TESTS ?= y
 26 CFG_WITH_STACK_CANARIES ?= y
 27 CFG_WITH_STATS ?= y
 28
 29 arm32-platform-cflags += -Wno-error=cast-align
 30
 31 $(call force,CFG_CRYPTO_SHA256_ARM32_CE,n)
 32 $(call force,CFG_CRYPTO_SHA256_ARM64_CE,n)
 33 $(call force,CFG_CRYPTO_SHA1_ARM32_CE,n)
 34 $(call force,CFG_CRYPTO_SHA1_ARM64_CE,n)
 35 $(call force,CFG_CRYPTO_AES_ARM64_CE,n)
</code></pre>
<h2 id="系统启动">系统启动</h2>
<h3 id="stage1">stage1</h3>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdn.net/20170523113635511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></figure>
<p>TEEOS是静态链接的，链接脚本可以看core/arch/arm/plat-gx/kern.ld.S内容是#include &quot;../kernel/kern.ld.S&quot; 说明这个链接脚本最终调用core/arch/arm/kernel/kern.ld.S，函数入口是ENTRY(_start),链接地址是CFG_TEE_LOAD_ADDR&gt;。根据入口_start代码在core/arch/arm/kernel/generic_entry_a32.S。</p>
<pre><code class="language-C">   1. _start:跳转reset
   
   2. reset
   
      bootargs_entry//保存loader传递过来的参数
   
         // entry r1, saved r7: (ARMv7 standard bootarg #1)
         // entry r2, saved r6: device tree address, (ARMv7 standard bootarg #2)
         // entry r1, saved r5: non-secure entry address (ARMv7 bootarg #0)
   
      disable cache
      plat_cpu_reset_early//这里是弱符号，真正的实现在plat-gx/plat_init.S里面，进入secure world
   
        /*
        * Disallow NSec to mask FIQ [bit4: FW=0]
        * Allow NSec to manage Imprecise Abort [bit5: AW=1]
        * Imprecise Abort trapped to Abort Mode [bit3: EA=0]
        * In Sec world, FIQ trapped to FIQ Mode [bit2: FIQ=0]
        * IRQ always trapped to IRQ Mode [bit1: IRQ=0]
        * Secure World [bit0: NS=0]
        */
       
        /*
        * Mandated HW config loaded
        *
        * SCTLR = 0x00000000
        * ACTRL = 0x00000040
        * - core NOT booted in full SMP (FW bit0=0)
        * NSACR = 0x00000C00
        * - NSec cannot change ACTRL.SMP (NS_SMP bit18=0)
        * - NSec can use SIMD/VFP (CP10/CP11) (bit15:14=2b00, bit11:10=2b11)
        */
   3. Reset primary   
      1. copy代码到运行地址,清理bss
      2. plat_cpu_reset_late//初始化cpu频率，由具体平台main.c里面代码实现
      3. console_init//初始化串口
      4. inval_cache_vrange
      5. 配置mmu
   
   4. generic_boot_init_primary:调转stage2。
</code></pre>
<h3 id="stage2">stage2</h3>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdn.net/20170523114027645?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<p>stage2代码在core/arch/arm/kernel/generic_boot.c。</p>
<pre><code class="language-C">661 static void init_primary_helper(unsigned long pageable_part,
662 ▸       ▸       ▸       ▸       unsigned long nsec_entry, unsigned long fdt)
663 {//第二个参数是内核的地址，第三个参数是fdt地址。
664 ▸       /*
665 ▸       ┆* Mask asynchronous exceptions before switch to the thread vector
666 ▸       ┆* as the thread handler requires those to be masked while
667 ▸       ┆* executing with the temporary stack. The thread subsystem also
668 ▸       ┆* asserts that the foreign interrupts are blocked when using most of
669 ▸       ┆* its functions.
670 ▸       ┆*/
671 ▸       thread_set_exceptions(THREAD_EXCP_ALL);//设置运行哪些异常处理
672 ▸       init_vfp_sec();//初始化浮点运算单元
673 ▸       init_runtime(pageable_part);//初始化TEE运行用到的内存，初始化线程内存，malloc内存、TA内存
674
675 ▸       thread_init_primary(generic_boot_get_handlers());//初始化TEE线程栈，异常处理
676 ▸       thread_init_per_cpu();
677 ▸       init_sec_mon(nsec_entry);//设置好kernel地址等待tee完成启动之后跳转到这个地址
678 ▸       init_fdt(fdt);//初始化fdt
679 ▸       configure_console_from_dt(fdt);
680
681 ▸       IMSG(&quot;OP-TEE version: %s&quot;, core_v_str);
682 ▸       IMSG(&quot;OP-TEE NS:0x%lx, FTD:0x%lx\n&quot;, nsec_entry, fdt);
683
684 ▸       main_init_gic();//初始化gic中断控制器
685 ▸       init_vfp_nsec();//初始化非安全环境的vfp
686 ▸       if (init_teecore() != TEE_SUCCESS)//初始化share memory加上初始化其他initcall
687 ▸       ▸       panic();
688 ▸       DMSG(&quot;Primary CPU switching to normal world boot\n&quot;);
689 }
</code></pre>
<h3 id="服务">服务</h3>
<ol>
<li>service_init、initcall1</li>
</ol>
<ul>
<li>register_supplicant_user_ta：加载ta image</li>
<li>verify_pseudo_tas_conformance：校验optee os内部的ta的合法性</li>
<li>tee_cryp_init：crypto功能初始化</li>
<li>tee_se_manager_init：mutex初始化</li>
</ul>
<ol start="2">
<li>servcie_init_late、initcall2</li>
</ol>
<ul>
<li>tee_fs_init_key_manager： 安全存储key生成</li>
</ul>
<h3 id="驱动">驱动</h3>
<ol>
<li>driver_init、initcall3：芯片驱动模块初始化</li>
<li>driver_init_late、initcall4：自定义驱动device结构模块初始化</li>
</ol>
<pre><code class="language-C"> 16 #define tee_device_register(...) static const TEE_Device __head \
 17         __used __section(&quot;.device&quot;) = { __VA_ARGS__ }
</code></pre>
<h2 id="ta">TA</h2>
<h3 id="system">system</h3>
<pre><code class="language-C"> 62 #define pseudo_ta_register(...) static const struct pseudo_ta_head __head \
 63                         __used __section(&quot;ta_head_section&quot;) = { __VA_ARGS__ }
</code></pre>
<p>pseudo_ta_register定义了系统ta的到ta_head_section这个特殊的段里，在系统初始化的时候verify_pseudo_tas_conformance里面实现的初始化。</p>
<ul>
<li>gprof: core/arch/arm/pta/gprof.c</li>
<li>interrupt_tests.ta: core/arch/arm/pta/Iiterrupt_tests.c</li>
<li>stats.ta: core/arch/arm/pta/stats.c</li>
<li>se_api_self_tests.ta: core/arch/arm/pta/se_api_self_tests.c</li>
<li>socket: core/arch/arm/tee/pta_socket.c</li>
<li>invoke_tests.pta: core/arch/arm/pta/pta_invoke_test.c</li>
</ul>
<h3 id="sign">sign</h3>
<h1 id="ree">REE</h1>
<h2 id="用户">用户</h2>
<p>当CA接口处于userspace层面，整个调用过程需要经过kernel space层面， linux driver层面， Monitor态中断处理层面， TEE OS kernel层面， TEE的userspace层面（TA）。</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdn.net/20170511210145320" alt="img"></figure>
<h3 id="libteec">libteec</h3>
<p>libteec库是OP-TEE提供给用户在linux userspace层面调用的接口实现,libteec代码的具体实现存放在optee_client/libteec目录下，OP-TEE提供给linux端使用的接口源代码的实现存放在optee_client/libteec/src/tee_client_api.c</p>
<pre><code class="language-C">shenjch@vm:v1.9-dev/tee/optee_client/libteec&gt; tree
.
├── include
│   ├── linux
│   │   └── tee.h
│   └── teec_benchmark.h
├── Makefile
└── src
    ├── teec_benchmark.c
    ├── tee_client_api.c
    └── teec_trace.c
</code></pre>
<pre><code class="language-C">//初始化一个TEEC_Context变量，该变量用于CA和TEE之间建立联系。其中参数name是用来定义TEE的身份，如果该参数为NULL，则CA将会选择默认的TEE方案来建立联系
1. TEEC_Result TEEC_InitializeContext(const char *name, TEEC_Context *ctx)；
//释放一个已经被初始化过的类型为TEEC_Context变量，关闭CA与TEE之间的连接。在调用该函数之前必须确保打开的session已经被关闭了。
2. void TEEC_FinalizeContext(TEEC_Context *ctx)；
//打开一个CA与对应TA之间的一个session，该session用于该CA与对应TA之间的联系，该CA需要连接的TA是由UUID指定的。session具有不同的打开和连接方式，根据不同的打开和连接方式CA可以在执行打开session的时候传递数据给TA，以便TA对打开操作做出权限检查。
3. TEEC_Result TEEC_OpenSession(TEEC_Context *ctx, TEEC_Session *session,const TEEC_UUID *destination,uint32_t connection_method, const void *connection_data,TEEC_Operation *operation, uint32_t *ret_origin)；
//关闭已经被初始化的CA与对应TA之间的session，在调用该函数之前需要保证所有的command已经执行完毕。如果session为NULL,则不执行任何操作。
4. void TEEC_CloseSession(TEEC_Session *session)
//通过cmd_id和打开的session，来通知session对应的TA执行cmd_id指定的操作。
5. TEEC_Result TEEC_InvokeCommand(TEEC_Session *session, uint32_t cmd_id,TEEC_Operation *operation, uint32_t *error_origin)
//取消某个CA与TA之间的操作，该接口只能由除执行TEEC_OpenSession和TEEC_InvokeCommand的thread之外的其他thread进行调用，而在TA端或者TEE OS可以选着并不响应该请求。只有当operation中的started域被设置成0之后，该操作方可有效。
6. void TEEC_RequestCancellation(TEEC_Operation *operation)
//注册一块在CA端的内存作为CA与TA之间的共享内存。
7. TEEC_Result TEEC_RegisterSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
//注册一块在CA与TA之间的共享文件，在CA端会将文件的描述符fd传递給OP-TEE，其内容被存放到shm中。
8. TEEC_Result TEEC_RegisterSharedMemoryFileDescriptor(TEEC_Context *ctx,TEEC_SharedMemory *shm,int
 fd)
//分配一块共享内存，共享内存是由OP-TEE中分配的,OP-TEE分配了共享内存之后将会返回该内存块的fd给CA，CA将会将fd映射到系统内存，然后将地址保存到shm中。
9. TEEC_Result TEEC_AllocateSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
//释放已经被分配或者是注册过的共享内存。
10. void TEEC_ReleaseSharedMemory(TEEC_SharedMemory *shm)
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdn.net/20170611163138066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<ul>
<li>在libteec中调用open函数来打开/dev/tee0设备的时候，最终会调用到tee_fops中的open成员指定的函数指针tee_open。</li>
<li>当在libteec和tee_supplicant打开了对应的设备之后，如果需要release设备，则可以调用该设备的release来实现，在userspace层面调用完成之后，最终会调用到OP-TEE驱动的release成员变量tee_release。</li>
<li>在libteec中获取OP-TEE版本信息，创建和关闭session，调用TA，分配和注册共享内存和fd以及释放共享内存，接收来自OP-TEE的请求以及回复数据给OP-TEE都是通过ioctl来完成的。在libteec和tee_supplicant中通过带上对应的参数调用ioctl函数来实现对应的操作需求，最终会调用到OP-TEE驱动中file_operation结构体变量tee_fops变量中的tee_ioctl函数</li>
</ul>
<h3 id="tee-supplicant">tee-supplicant</h3>
<p>tee_supplicant的主要作用是使OP-TEE能够通过tee_supplicant来访问REE端文件系统中的资源，例如加载存放在文件系统中的TA镜像到TEE中，对REE端数据库的操作，对EMMC中RPMB分区的操作，提供socket通信等。 其源代码optee_client/tee-supplicant目录中。编译之后会生成一个名字为tee_supplicant的可执行文件，该可执行文件在REE启动的时候会作为一个后台程序被自动启动，而且常驻于系统中。</p>
<p>tee_supplicant可执行文件在Linux启动的时候会被作为后台程序启动。启动的动作存放在build/init.d.optee文件中，其内容如下：</p>
<pre><code class="language-shell">#!/bin/sh  
#  
# /etc/init.d/optee  
#  
# Start/stop tee-supplicant (OP-TEE normal world daemon)  
#  
case &quot;$1&quot; in  
    start)  
    if [ -e /bin/tee-supplicant -a -e /dev/teepriv0 ]; then  
        echo &quot;Starting tee-supplicant...&quot;  
        tee-supplicant&amp; #将tee_supplicat以后台方式启动  
        exit 0  
    else  
        echo &quot;tee-supplicant or TEE device not found&quot;  
        exit 1  
    fi  
  
        ;;  
    stop)  
    killall tee-supplicant  
    ;;  
    status)  
    cat /dev/teepriv0 2&gt;&amp;1 | grep -q &quot;Device or resource busy&quot; || not=&quot;not &quot;  
    echo &quot;tee-supplicant is ${not}active&quot;  
    ;;  
esac  
</code></pre>
<p>tee_supplicant启动后作为Linux中的一个后台程序运行，起到处理RPC请求 service的作用。通过类似于C/S的方式为OP-TEE提供对REE端文件系统的操作。该可执行文件的源代码的入口函数存放在optee_client/tee-supplicant/src/tee_supplicant.c文件中。</p>
<p>tee_supplicant中的loop循环</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdn.net/20170608121635411?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<p>加载TA image到共享内存，当TA请求的func ID为RPC_CMD_LOAD_TA时，tee_supplicant将会到文件系统中将TA镜像的内容读取到共享内存中。该操作是通过调用load_ta函数来实现的，该函数定义在tee_supplicant.c文件中</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdn.net/20170608141446987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<h2 id="驱动-2">驱动</h2>
<h3 id="加载">加载</h3>
<p>OP-TEE驱动主要作用是REE与TEE端进行数据交互的桥梁作用,tee_supplicant和libteec调用接口之后几乎都会首先通过系统调用陷入到kernel space，然后kernel根据传递的参数找到OP-TEE驱动，并命中驱动的operation结构体中的具体处理函数来完成实际的操作，对于OP-TEE驱动，一般都会触发SMC调用，并带参数进入到ARM cortex的monitor模式，在monitor模式中对执行normal world和secure world的切换，待状态切换完成之后，会将驱动端带入的参数传递給OP-TEE中的thread进行进一步的处理。OP-TEE驱动的源代码存放在linux/drivers/tee目录:</p>
<pre><code class="language-c">shenjch@vm:v1.9-dev/linux-4.4.25/drivers/tee&gt; tree .
.
├── Kconfig
├── Makefile
├── optee
│   ├── call.c
│   ├── core.c
│   ├── Kconfig
│   ├── Makefile
│   ├── optee_msg.h
│   ├── optee_private.h
│   ├── optee_smc.h
│   ├── rpc.c
│   └── supp.c
├── tee_core.c
├── tee_private.h
├── tee_shm.c
└── tee_shm_pool.c
</code></pre>
<p>OP-TEE驱动的加载过程分为两部分，第一部分是创建class和分配设备号，第二部分就是probe过程。在正式介绍之前首先需要明白两个linux kernel中加载驱动的函数：subsys_initcall和module_init函数。OP-TEE驱动的第一部分是调用subsys_initcall函数来实现，而第二部分则是调用module_init来实现。整个OP-TEE驱动的初始化流程图如下图所示:</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdn.net/20170608202139541?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<ul>
<li>tee_init函数初始化设备号和class,
<ul>
<li>linux/drivers/tee/tee_core.c</li>
</ul>
</li>
<li>optee_driver_init函数执行
<ul>
<li>/drivers/tee/optee/core.c</li>
</ul>
</li>
</ul>
<h3 id="tee设备数据结构">tee设备数据结构</h3>
<pre><code class="language-C">static const struct file_operations tee_fops = {  
    .owner = THIS_MODULE,   //驱动属于哪儿谁  
    .open = tee_open,   //驱动文件的open操作的具体实现的函数指针  
    .release = tee_release, //驱动文件的release操作的具体实现的函数指针  
    .unlocked_ioctl = tee_ioctl,    //驱动文件的ioctl操作的具体实现的函数指针  
    .compat_ioctl = tee_ioctl,   //驱动文件的ioctl操作的具体实现的函数指针，用户空间为32位，而内核为64位时使用  
};  

static struct tee_driver_ops optee_ops = {  
    .get_version = optee_get_version,   //获取OP-TEE版本信息的接口函数  
    .open = optee_open,  //打开/dev/tee0设备的具体实现，初始化列表和互斥体，返context  
    .release = optee_release, //释放掉打开的/dev/tee0设备资源，并通知secure world关闭session  
    .open_session = optee_open_session, //打开session，以便CA于TA进行交互  
    .close_session = optee_close_session, //关闭已经打开的session，断开CA与TA之间的交互  
    .invoke_func = optee_invoke_func,   //通过smc操作发送CA请求到对应TA  
    .cancel_req = optee_cancel_req, //取消CA端已经发送的smc请求  
};  
static struct tee_driver_ops optee_supp_ops = {  
    .get_version = optee_get_version,   //获取OP-TEE的版本信息  
    .open = optee_open, //打开/dev/teepriv0设备的具体实现  
    .release = optee_release, //释放掉打开的/dev/teepriv0设备，并通知secure world关闭session  
    .supp_recv = optee_supp_recv, //接收从OP-TEE发送给tee_supplicant的请求  
    .supp_send = optee_supp_send,  //执行完OP-TEE请求的操作后将结果和数据发送给OP-TEE  
};  
static struct dma_buf_ops tee_shm_dma_buf_ops = {  
    .map_dma_buf = tee_shm_op_map_dma_buf,  //暂未实现  
    .unmap_dma_buf = tee_shm_op_unmap_dma_buf,  //暂未实现  
    .release = tee_shm_op_release,  //释放掉指定的共享内存  
    .kmap_atomic = tee_shm_op_kmap_atomic, //暂未实现  
    .kmap = tee_shm_op_kmap,    //暂未实现  
    .mmap = tee_shm_op_mmap,    //dma共享内存进行地址映射  
};  
</code></pre>
<h1 id="模式切换">模式切换</h1>
<h2 id="中断向量表">中断向量表</h2>
<p>在一个完整的系统中都会存在中断，如果支持trustzone并且具有TEE的支持，则每个CPU将具有两个种状态：secure world, non-sercure world，通过write_scr的NS bit来切换secure world, non-sercure world，plat_cpu_reset_early进入secure world，.sm_ret_to_nsec返回non-sercure world。在ARM中secure world和non-secure world都具monitor模式，有独立的VBAR寄存器和中断向量表。而当CPU处于monitor态时，CPU将具有独立的中断向量表和MVBAR寄存器。而且在secure world态时需要使能FIQ的支持，而在non-secure world态时则需要禁止FIQ的支持。其在两种态之间的切换的时候需要做到对应的上下文的保存和恢复操作。</p>
<h3 id="vbar配置">VBAR配置</h3>
<p>在初始化阶段TEE的中断向量的加载和配置将会通过thread_init_vbar函数来实现，从初始化起始到配置中断向量表的整个调用过程如下：_start--&gt; b reset--&gt;b reset_primary--&gt;bl generic_boot_init_primary--&gt;init_primary_helper--&gt;thread_init_per_cpu—&gt;thread_init_vbar；thread_init_vbar函数为汇编代码内容如下，定义在optee_os_core/arch/arm/kernel/thread_a32.S文件中：</p>
<pre><code class="language-C">FUNC thread_init_vbar , :  
UNWIND( .fnstart)  
    /* Set vector (VBAR) */  
    ldr r0, =thread_vect_table  //将中断向量表的地址赋值给r0寄存器  
    write_vbar r0//将r0寄存器指定的地址中的内容写入到VBAR寄存器中来设定TEE的中断向量表  
    bx  lr  //跳转返回  
UNWIND( .fnend)  
END_FUNC thread_init_vbar  

LOCAL_FUNC thread_vect_table , :  
UNWIND( .fnstart)  
UNWIND( .cantunwind)  
    b   .           /* Reset            */  
    b   thread_und_handler  /* Undefined instruction    */  
    b   thread_svc_handler  /* System call          */  
    b   thread_pabort_handler   /* Prefetch abort       */  
    b   thread_dabort_handler   /* Data abort           */  
    b   .           /* Reserved         */  
    b   thread_irq_handler  /* IRQ              */  
    b   thread_fiq_handler  /* FIQ              */  
UNWIND( .fnend)  
END_FUNC thread_vect_table  
</code></pre>
<h3 id="mvbar配置">MVBAR配置</h3>
<p>在OP-TEE的启动的过程中，将会调用init_sec_mon函数来完成monitor态的相关初始化，该函数被定义在optee_os/core/arch/arm/kernel/thread.c文件中，从初始化的时候调用的流程如下：_start--&gt; b reset--&gt;b reset_primary--&gt;bl generic_boot_init_primary--&gt;init_primary_helper—&gt;init_sec_mon。该函数会调用sm_init来进行monitor的相关初始化，sm_init函数定义在optee_os/core/arch/arm/sm/sm_a32.S文件中,内容如下：</p>
<pre><code class="language-C">static void init_sec_mon(size_t pos __maybe_unused)  
{  
#if !defined(CFG_WITH_ARM_TRUSTED_FW)  
    /* Initialize secure monitor */  
/* 调用sm_init函数完成Monitor态的相关初始化 */  
    sm_init(GET_STACK(stack_tmp[pos]));  
#endif  
} 

/* void sm_init(vaddr_t stack_pointer); */  
FUNC sm_init , :  
UNWIND( .fnstart)  
    /* Set monitor stack */  
    mrs r1, cpsr    //设置monitor的栈  
    cps #CPSR_MODE_MON  
    /* Point just beyond sm_ctx.sec */  
    sub sp, r0, #(SM_CTX_SIZE - SM_CTX_NSEC)  
    msr cpsr, r1  
  
    /* Set monitor vector (MVBAR) */  
    ldr r0, =sm_vect_table  //获取monitor态的中断向量表变量  
    write_mvbar r0      //将中断向量表的地址写入到MVBAR寄存器中  
  
    bx  lr  
END_FUNC sm_init 

LOCAL_FUNC sm_vect_table , :  
UNWIND( .fnstart)  
UNWIND( .cantunwind)  
    b   .       /* Reset            */  
    b   .       /* Undefined instruction    */  
    b   sm_smc_entry    /* Secure monitor call */  
    b   .       /* Prefetch abort       */  
    b   .       /* Data abort           */  
    b   .       /* Reserved         */  
    b   .       /* IRQ              */  
    b   sm_fiq_entry    /* FIQ              */  
UNWIND( .fnend)  
END_FUNC sm_vect_table 
</code></pre>
<h3 id="fiq处理">FIQ处理</h3>
<p>在OP-TEE的启动的过程中，将会调用init_sec_mon函数来完成monitor态的相关初始化，该函数被定义在optee_os/core/arch/arm/kernel/thread.c文件中，从初始化的时候调用的流程如下：</p>
<p>_start--&gt; b reset--&gt;b reset_primary--&gt;bl generic_boot_init_primary--&gt;init_primary_helper--&gt;init_sec_mon</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdn.net/20170613153313684?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<h3 id="irq处理">IRQ处理</h3>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdn.net/20170528013655282?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<h2 id="monitor模式处理">monitor模式处理</h2>
<h3 id="secure-world">secure world</h3>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdn.net/20170528203118437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<h3 id="non-secure-world">non secure world</h3>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdn.net/20170528203445672?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<h2 id="linux到tee切换">linux到tee切换</h2>
<p>libteec和tee_supplicant调用接口之后最终会调用到OP-TEE驱动来触发对应的SMC操作。在OP-TEE驱动中触发SMC操作的方法是调用arm_smccc_smc(a0, a1, a2, a3, a4, a5, a6, a7, res)来实现，其中在REE端需要传递給TEE侧的数据被存放在a0~a7中。调用上述函数自后，CPU中的cortex就会切换到monitor模式，进入monitor模式之后首先会去获取MVBAR寄存器中存放的monitor模式的中断向量表地址，然后查找monitor模式中断向量表的sm_smc_entry函数来对请求进行处理。在sm_smc_entry中对当前SCR寄存器中的NS为来判定请求是来自于secure world还是normal world。如果请求来自于REE侧，则程序会执行smc_from_nsec分支完成SCR中NS的设置并调转到sm_from_nsec函数继续执行。该判定是通过判定r0寄存器中存放的数据中的第31个bit的值是1还是0，如果bit31的值是1，则表面该smc请求时快速smc(fast smc)，如果该值为0则是标准smc请求。</p>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdn.net/20170703175022801?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<p>在OP-TEE中用于处理各种来自外部或者的monitor模式请求的入口函数都存放在OP-TEE的线程向量表thread_vector_table中。该项量的实现在optee_os/core/arch/arm/kernel/thread_a32.S文件中</p>
<pre><code class="language-C">167 /*
168  * Vector table supplied to ARM Trusted Firmware (ARM-TF) at
169  * initialization.  Also used when compiled with the internal monitor, but
170  * the cpu_*_entry and system_*_entry are not used then.
171  *
172  * Note that ARM-TF depends on the layout of this vector table, any change
173  * in layout has to be synced with ARM-TF.
174  */
175 FUNC thread_vector_table , :
176 UNWIND( .fnstart)
177 UNWIND( .cantunwind)
178         b       vector_std_smc_entry
179         b       vector_fast_smc_entry
180         b       vector_cpu_on_entry
181         b       vector_cpu_off_entry
182         b       vector_cpu_resume_entry
183         b       vector_cpu_suspend_entry
184         b       vector_fiq_entry
185         b       vector_system_off_entry
186         b       vector_system_reset_entry
187 UNWIND( .fnend)
188 END_FUNC thread_vector_table
</code></pre>
<p>注意该线程向量表与OP-TEE的中断处理向量表thread_vect_table是不一样的。thread_vector_table 属于线程级别，会被monitor模式或者其他中断处理函数调用到，而thread_vect_table才是OP-TEE存放在VBAR寄存器中的中断向量表。当在secure world状态下产生了FIQ事件时，将会调用中断向量表thread_vect_table中的FIQ中断处理函数，然后才会调用到thread_vector_table中给的vector_fiq_entry来执行FIQ的后续处理。</p>
<pre><code>tee_entry_std（get_cmd_buffer这里将shm共享内存的物理地址专为虚拟地址，这个ree通过smc传递过来的参数存放地址物理空间4k在ree预留）-&gt;entry_invoke_command（copy_in_params）-&gt;tee_ta_invoke_command-&gt;res = sess-&gt;ctx-&gt;ops-&gt;enter_invoke_cmd(sess, cmd, param, err);-&gt;user_ta_enter_invoke_cmd-&gt;user_ta_enter(tee_mmu_map_param将shm的物理地址专为ta的虚拟地址)-&gt;thread_enter_user_mode(utc-&gt;entry_func, utc-&gt;is_32bit,根据自己的uuid找到自己的接口)-&gt;.entry.ptr32 = { .lo = (uint32_t)__utee_entry },-&gt;__utee_entry-&gt;entry_invoke_command-&gt;TA_InvokeCommandEntryPoint
</code></pre>
<h3 id="fast-smc">fast smc</h3>
<pre><code class="language-C">LOCAL_FUNC vector_fast_smc_entry , :  
UNWIND( .fnstart)  
UNWIND( .cantunwind)  
    push    {r0-r7} //将r0~r7入栈  
    mov r0, sp  //将栈地址赋值给r0  
    bl  thread_handle_fast_smc  //调用thread_handle_fast_smc进行处理，参数为r0中的数据  
    pop {r1-r8} //处理完成之后，执行出栈操作  
    ldr r0, =TEESMC_OPTEED_RETURN_CALL_DONE     //r0存放fast smc处理操作的结果  
    smc #0  //触发smc请求 切换到monitor模式，返回normal world中  
    b   .   /* SMC should not return */  
UNWIND( .fnend)  
END_FUNC vector_fast_smc_entry  
  
void thread_handle_fast_smc(struct thread_smc_args *args)  
{  
/* 使用canaries原理检查栈空间是否存在溢出或者被破坏 */  
    thread_check_canaries();  
  
/* 调用thread_fast_smc_handler_ptr处理smc请求 */  
    thread_fast_smc_handler_ptr(args);  
    /* Fast handlers must not unmask any exceptions */  
    assert(thread_get_exceptions() == THREAD_EXCP_ALL);  
}  

void tee_entry_fast(struct thread_smc_args *args)  
{  
    switch (args-&gt;a0) {  
  
    /* Generic functions */  
/* 获取API被调用的次数，可以根据实际需求实现 */  
    case OPTEE_SMC_CALLS_COUNT:  
        tee_entry_get_api_call_count(args);  
        break;  
/* 获取OP-TEE API的UID值 */  
    case OPTEE_SMC_CALLS_UID:  
        tee_entry_get_api_uuid(args);  
        break;  
/* 获取OP-TEE中API的版本信息 */  
    case OPTEE_SMC_CALLS_REVISION:  
        tee_entry_get_api_revision(args);  
        break;  
/* 获取OP-TEE OS的UID值 */  
    case OPTEE_SMC_CALL_GET_OS_UUID:  
        tee_entry_get_os_uuid(args);  
        break;  
/* 获取OS的版本信息 */  
    case OPTEE_SMC_CALL_GET_OS_REVISION:  
        tee_entry_get_os_revision(args);  
        break;  
  
    /* OP-TEE specific SMC functions */  
/* 获取OP-TEE与驱动之间的共享内存配置信息 */  
    case OPTEE_SMC_GET_SHM_CONFIG:  
        tee_entry_get_shm_config(args);  
        break;  
/* 获取I2CC的互斥体信息 */  
    case OPTEE_SMC_L2CC_MUTEX:  
        tee_entry_fastcall_l2cc_mutex(args);  
        break;  
/* OP-TEE的capabilities信息 */  
    case OPTEE_SMC_EXCHANGE_CAPABILITIES:  
        tee_entry_exchange_capabilities(args);  
        break;  
/* 关闭OP-TEE与驱动的共享内存的cache */  
    case OPTEE_SMC_DISABLE_SHM_CACHE:  
        tee_entry_disable_shm_cache(args);  
        break;  
/* 使能OP-TEE与驱动之间共享内存的cache */  
    case OPTEE_SMC_ENABLE_SHM_CACHE:  
        tee_entry_enable_shm_cache(args);  
        break;  
/* 启动其他cortex的被使用 */  
    case OPTEE_SMC_BOOT_SECONDARY:  
        tee_entry_boot_secondary(args);  
        break;  
  
    default:  
        args-&gt;a0 = OPTEE_SMC_RETURN_UNKNOWN_FUNCTION;  
        break;  
    }  
} 
</code></pre>
<h3 id="std-smc">std smc</h3>
<pre><code class="language-C">LOCAL_FUNC vector_std_smc_entry , :  
UNWIND( .fnstart)  
UNWIND( .cantunwind)  
    push    {r0-r7} //将参数入栈  
    mov r0, sp  //将栈指针赋值给r0寄存器  
    bl  thread_handle_std_smc   //调用处理函数，参数的地址存放在r0寄存器中  
    /* 
     * Normally thread_handle_std_smc() should return via 
     * thread_exit(), thread_rpc(), but if thread_handle_std_smc() 
     * hasn't switched stack (error detected) it will do a normal &quot;C&quot; 
     * return. 
     */  
    pop {r1-r8} //出栈操作  
    ldr r0, =TEESMC_OPTEED_RETURN_CALL_DONE //标记OP-TEE处理完成  
    smc #0  //调用smc切回到normal world  
    b   .   /* SMC should not return */  
UNWIND( .fnend)  
END_FUNC vector_std_smc_entry 

void thread_handle_std_smc(struct thread_smc_args *args)
{
        thread_check_canaries();


        if (args-&gt;a0 == OPTEE_SMC_CALL_RETURN_FROM_RPC)
                thread_resume_from_rpc(args);
        else
               thread_alloc_and_run(args);

}

static void thread_alloc_and_run(struct thread_smc_args *args)
{
        
        init_regs(threads + n, args);

        
}

static void init_regs(struct thread_ctx *thread,
                struct thread_smc_args *args)
{
        thread-&gt;regs.pc = (uint32_t)thread_std_smc_entry;
}

void __weak __thread_std_smc_entry(struct thread_smc_args *args)
{

        thread_std_smc_handler_ptr(args);

     thread_std_smc_handler_ptr = handlers-&gt;std_smc;
}

void __weak tee_entry_std(struct thread_smc_args *smc_args)
{
 arg = mobj_get_va(mobj, 0);
        assert(arg &amp;&amp; mobj_is_nonsec(mobj));

        /* Enable foreign interrupts for STD calls */
        thread_set_foreign_intr(true);
        switch (arg-&gt;cmd) {
        case OPTEE_MSG_CMD_OPEN_SESSION:
                entry_open_session(smc_args, arg, num_params);
                break;
        case OPTEE_MSG_CMD_CLOSE_SESSION:
                entry_close_session(smc_args, arg, num_params);
                break;
        case OPTEE_MSG_CMD_INVOKE_COMMAND:
                entry_invoke_command(smc_args, arg, num_params);
                break;
        case OPTEE_MSG_CMD_CANCEL:
                entry_cancel(smc_args, arg, num_params);
                break;
        case OPTEE_MSG_CMD_REGISTER_SHM:
                register_shm(smc_args, arg, num_params);
                break;
        case OPTEE_MSG_CMD_UNREGISTER_SHM:
                unregister_shm(smc_args, arg, num_params);
                break;

        default:
                EMSG(&quot;Unknown cmd 0x%x&quot;, arg-&gt;cmd);
                smc_args-&gt;a0 = OPTEE_SMC_RETURN_EBADCMD;
        }
        mobj_free(mobj);
}
</code></pre>
<h1 id="ta开发">TA开发</h1>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdn.net/20170510115636564?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<h1 id="内存">内存</h1>
<p>安全空间28M，非安全空间4M，安全空间分为TEE_RAM和TA_RAM，非安全空间SHMEM。core/arch/arm/plat-gx/platform_config.h</p>
<pre><code>/*
 * TEE/TZ DRAM layout:
 *
 *  +---------------------------------------+  &lt;- TEE_RAM_START   = TZDRAM_BASE(内存尾部32MB)
 *  | TEE private secure |  TEE_RAM          |  ^
 *  |   external memory  |                  |   v + 4MB
 *  +---------------------------------------+  &lt;- TA_RAM_START    = TZDRAM_BASE + 4MB
 *  | TEE private secure |  TA_RAM          |   ^
 *  |   external memory  |                  |   v + 24MB
 *  +---------------------------------------+  &lt;- TEE_SHMEM_START = TZDRAM_BASE + 4MB + 24MB
 *  |     Non secure     |  SHM             |   |
 *  |   shared memory    |                  |   |  + 4MB
 *  +---------------------------------------+   v
 *
 *  TEE_RAM : 4  MB
 *  TA_RAM  : 24 MB
 *  SHM_RAM : 4  MB
 */

</code></pre>
<h3 id="内存类型">内存类型</h3>
<h3 id="mmu初始化和映射表">MMU初始化和映射表</h3>
<p>MMU初始化函数 core_init_mmu_map在文件core/arch/arm/mm/core_mmu.c。</p>
<pre><code>void core_init_mmu_map(void)
{
        struct tee_mmap_region *map;
        size_t n;

        for (n = 0; n &lt; ARRAY_SIZE(secure_only); n++) {
                if (pbuf_intersects(nsec_shared, secure_only[n].paddr,
                                    secure_only[n].size))
                        panic(&quot;Invalid memory access config: sec/nsec&quot;);
        }
        //检查安全空间和非安全空间是否重合，具体分配看core/arch/arm/plat-gx/platform_config.h
        
        /*
        static struct memaccess_area secure_only[] __nex_data = {
        MEMACCESS_AREA(TZDRAM_BASE, TZDRAM_SIZE),
};

static struct memaccess_area nsec_shared[] __nex_data = {
        MEMACCESS_AREA(TEE_SHMEM_START, TEE_SHMEM_SIZE),
};

        */

        COMPILE_TIME_ASSERT(CFG_MMAP_REGIONS &gt;= 13);
        init_mem_map(static_memory_map, ARRAY_SIZE(static_memory_map));

        map = static_memory_map;
        while (!core_mmap_is_end_of_table(map)) {
                switch (map-&gt;type) {
                case MEM_AREA_TEE_RAM:
                case MEM_AREA_TEE_RAM_RX:
                case MEM_AREA_TEE_RAM_RO:
                case MEM_AREA_TEE_RAM_RW:
                case MEM_AREA_NEX_RAM_RW:
                        if (!pbuf_is_inside(secure_only, map-&gt;pa, map-&gt;size))
                                panic(&quot;TEE_RAM can't fit in secure_only&quot;);
                        break;
                case MEM_AREA_TA_RAM:
                        if (!pbuf_is_inside(secure_only, map-&gt;pa, map-&gt;size))
                                panic(&quot;TA_RAM can't fit in secure_only&quot;);
                        break;
                case MEM_AREA_NSEC_SHM:
                        if (!pbuf_is_inside(nsec_shared, map-&gt;pa, map-&gt;size))
                                panic(&quot;NS_SHM can't fit in nsec_shared&quot;);
                        break;
                case MEM_AREA_SEC_RAM_OVERALL:
                case MEM_AREA_TEE_COHERENT:
                case MEM_AREA_TEE_ASAN:
                case MEM_AREA_IO_SEC:
                case MEM_AREA_IO_NSEC:
                case MEM_AREA_RAM_SEC:
                case MEM_AREA_RAM_NSEC:
                case MEM_AREA_RES_VASPACE:
                case MEM_AREA_SHM_VASPACE:
                case MEM_AREA_PAGER_VASPACE:
                        break;
                default:
                        EMSG(&quot;Uhandled memtype %d&quot;, map-&gt;type);
                        panic();
                }
                                }
                map++;
        }

        core_init_mmu(static_memory_map);
        dump_xlat_table(0x0, 1);
}
</code></pre>
<pre><code>static void init_mem_map(struct tee_mmap_region *memory_map, size_t num_elems)
{
        const struct core_mmu_phys_mem *mem;
        struct tee_mmap_region *map;
        size_t last = 0;
        size_t __maybe_unused count = 0;
        vaddr_t va;
        vaddr_t end;
        bool __maybe_unused va_is_secure = true; /* any init value fits */
//这里需要注意，总共现在memory_map最大是64个控制块，如果register_mem太多这里会出错。
        for (mem = phys_mem_map_begin; mem &lt; phys_mem_map_end; mem++) {
                struct core_mmu_phys_mem m = *mem;

                /* Discard null size entries */
                if (!m.size)
                        continue;

                /* Only unmapped virtual range may have a null phys addr */
                assert(m.addr || !core_mmu_type_to_attr(m.type));

#if 1
                if (m.type == MEM_AREA_IO_NSEC || m.type == MEM_AREA_IO_SEC) {
                        m.addr = ROUNDDOWN(m.addr, SMALL_PAGE_SIZE);
                        m.size = ROUNDUP(m.size + (mem-&gt;addr - m.addr), SMALL_PAGE_SIZE);
                }
#endif
                add_phys_mem(memory_map, num_elems, &amp;m, &amp;last);
        }
}
</code></pre>
<pre><code>dump_mmap_table
</code></pre>
<pre><code>这个函数是设置共享内存的，两个区域，ree和tee的共享内存，tee的内核态和用户态共享内存。
static TEE_Result default_mobj_init(void)
{
        shm_mobj = mobj_phys_alloc(default_nsec_shm_paddr,
                                   default_nsec_shm_size, SHM_CACHE_ATTRS,
                                   CORE_MEM_NSEC_SHM);
        if (!shm_mobj)
                panic(&quot;Failed to register shared memory&quot;);

#ifdef CFG_SECURE_DATA_PATH
        sdp_mem_mobjs = core_sdp_mem_create_mobjs();
        if (!sdp_mem_mobjs)
                panic(&quot;Failed to register SDP memory&quot;);
#endif

        return TEE_SUCCESS;
}

driver_init_late(default_mobj_init);


static TEE_Result alloc_temp_sec_mem(size_t size, struct mobj **mobj,
                                     uint8_t **va)
{
        /* Allocate section in secure DDR */
#ifdef CFG_PAGED_USER_TA
        *mobj = mobj_seccpy_shm_alloc(size);
#else
        *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &amp;tee_mm_sec_ddr);
#endif
        if (!*mobj)
                return TEE_ERROR_GENERIC;

        *va = mobj_get_va(*mobj, 0);
        return TEE_SUCCESS;
}
</code></pre>
]]></content>
    </entry>
</feed>