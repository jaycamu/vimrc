<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TEE学习笔记 | x-kownledge</title>
<link rel="shortcut icon" href="https://jaycamu.github.io/x-knowledge//favicon.ico?v=1571202330925">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://jaycamu.github.io/x-knowledge//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://jaycamu.github.io/x-knowledge/">
  <img class="avatar" src="https://jaycamu.github.io/x-knowledge//images/avatar.png?v=1571202330925" alt="">
  </a>
  <h1 class="site-title">
    x-kownledge
  </h1>
  <p class="site-description">
    知止而后有定
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              TEE学习笔记
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-06-24 ·
              </time>
              
            </div>
            
            <div class="post-content">
              <h1 id="系统介绍">系统介绍</h1>
<p>如果系统芯片支持TrustZone技术且支持TEE，那么TEE将在系统中提供一个安全的运行环境，用于保护系统中的重要数据和安全操作。通常一个完成的系统除了有bootloader和kernel之外还需要有TEE OS。系统启动的时候使用secure boot功能来保护整个系统的image不被恶意篡改。OP-TEE是借助TrustZone技术实现的一种TEE方案。而TEE又属于整个系统中的一个部分，可以看作是与linux kernel同一个层面。</p>
<h1 id="trustzone硬件框架">TrustZone硬件框架</h1>
<p>TrustZone的技术是为了提高系统的安全性而提出的。而对做到对外部资源和内存资源的硬件隔离就是TrustZone的核心。这些硬件隔离包括：中断隔离，片上RAM和ROM的隔离，片外RAM和ROM的隔离，外围设备的硬件隔离，外部RAM和ROM的隔离。</p>
<p>为实现硬件层面的各种隔离就需要对整个系统的硬件和处理器核做出相应的扩展。这些扩展包括对处理器core的虚拟化实现也即将AMR core的运行状态分为了secure world态和non-secure world态。对总线的扩展，增加安全位读写信号线。对MMU的扩展，增加页表的安全位, 对cache的扩展，增加安全位。以及其他外围组件进行了相应的扩展，提供安全操作权限控制和安全操作信号。</p>
<h2 id="处理器核">处理器核</h2>
<p>在支持TrustZone技术的微处理器中，AMR实现了对cortex的虚拟化，将每个物理的处理器虚拟化成两个虚拟核，一个为安全核，一个普通安全核，也就是一个物理核存在secure wrold态和normal world态。为实现一个物理核上的两种状态的切换，ARM增加了一个monitor模式来实现处理器核两种状态的切换。关于微处理器核的状态切换和划分是通过设置CP15中的SCR寄存器来实现的。secure world和normal world的关系如下图所示。关于normal world与secure world之间的切换过程请参考3.3节。</p>
<h2 id="cache和mmu">cache和mmu</h2>
<p>在支持trustzone的soc上，会对MMU进行虚拟化，使得normal world和secure world都具有完全独立的一份TTBR0， TTBR1，TTBCR。也就是每个世界都具有单独的MMU页表。存放在MMU中的每一条页表描述符都会包含一个NS位来表示被映射的内存是属于安全内存还是非安全内存。虚拟化的MMU共享TLB，同样在TLB中的每一项也同样会打上NS标记，只不过该标记是用来表示该条转换是normal  world转化的还是secure world的转化。</p>
<p>cache也是共享的同样也做了扩展，在cache中的每一项都会按照normal world和secure world的状态打上对应的tag，这就能实现在不同的world下面，处理器只要属性自己world的cache就可以了。</p>
<h1 id="op-tee软件框架">OP-TEE软件框架</h1>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdn.net/20170523113635511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></figure>
<h1 id="tee-os">TEE OS</h1>
<h2 id="系统移植">系统移植</h2>
<h3 id="plat-gx">plat-gx</h3>
<ul>
<li>增加一个目录</li>
</ul>
<pre><code class="language-C">core/arch/arm/plat-gx
├── conf.mk                   //编译makefile配置
├── gx_core_pos.S
├── kern.ld.S                 //链接脚本
├── link.mk
├── main.c                    //平台初始化包括uart，中断控制器
├── platform_config.h         //平台内存、时钟、基地址配置
├── plat_init.S
└── sub.mk

</code></pre>
<h3 id="内存规划配置">内存规划配置</h3>
<ul>
<li>platform_config.h</li>
</ul>
<pre><code class="language-C"> 28 #ifndef PLATFORM_CONFIG_H
 29 #define PLATFORM_CONFIG_H
 30
 31 /* Make stacks aligned to data cache line length */
 32 #define STACK_ALIGNMENT           64
 33
 34 /* 16550 UART */
 35 #define CONSOLE_UART_BASE      0x82804000 /* UART0 */
 36 #define CONSOLE_BAUDRATE       115200
 37 #define CONSOLE_UART_CLK_IN_HZ 30000000
 38
 39 #define GIC_BASE               0xA2000000
 40 #define GICC_OFFSET            0x2000
 41 #define GICD_OFFSET            0x1000
 42
 43 #define CNTFRQ                 27000000
 44
 45 #define DRAM0_BASE             0x00000000
 46 #define DRAM0_SIZE             0x10000000
 47
 48 #define TZDRAM_SIZE            (32 * 1024 * 1024)//optee总内存大小
 49 #define CFG_SHMEM_START        (DRAM0_BASE + DRAM0_SIZE - TZDRAM_SIZE)
 50 #define CFG_SHMEM_SIZE         (4 * 1024 * 1024)//共享内存大小
 51
 52 #define TZDRAM_BASE            (CFG_SHMEM_START + CFG_SHMEM_SIZE)//optee的运行地址
 53
 54 #define CFG_TEE_CORE_NB_CORE   (2)
 55 #define CFG_TEE_RAM_VA_SIZE    (4 * 1024 * 1024)
 56 #define CFG_TEE_LOAD_ADDR      (TZDRAM_BASE + 0x20000)//ELF运行地址
 57
 58 #define CFG_TEE_RAM_PH_SIZE    CFG_TEE_RAM_VA_SIZE
 59 #define CFG_TEE_RAM_START      TZDRAM_BASE
 60
 61 #define CFG_TA_RAM_START       ROUNDUP((TZDRAM_BASE + CFG_TEE_RAM_VA_SIZE), CORE_MMU_DEVICE_SIZE)
 62
 63 # define CFG_TA_RAM_SIZE      (16 * 1024 * 1024)
 64
 65 #endif /* PLATFORM_CONFIG_H */
</code></pre>
<h3 id="编译">编译</h3>
<ul>
<li>conf.mk</li>
<li>make PLATFORM=gx</li>
</ul>
<pre><code>  1 PLATFORM_FLAVOR ?= SIRIUS
  2
  3 include core/arch/arm/cpu/cortex-a7.mk
  4
  5 core_arm32-platform-aflags▸ += -mfpu=neon
  6
  7 $(call force,CFG_8250_UART,y)
  8 $(call force,CFG_GENERIC_BOOT,y)
  9 $(call force,CFG_PM_STUBS,y)
 10 $(call force,CFG_SECURE_TIME_SOURCE_CNTPCT,y)
 11 $(call force,CFG_WITH_ARM_TRUSTED_FW,n)
 12 #$(call force,CFG_NS_ENTRY_ADDR, 0x10008000)
 13 #$(call force,CFG_DT_ADDR, 0x13ffc000)
 14 $(call force,CFG_GIC,y)
 15 $(call force,CFG_DT,y)
 16 $(call force,CFG_BOOT_SECONDARY_REQUEST,y)
 17 $(call force,CFG_ARM32_core,y)
 18 $(call force,CFG_TEE_PTA_DEVICE,y)
 19
 20 ta-targets = ta_arm32
 21
 22 CFG_NUM_THREADS ?= 4
 23 CFG_CRYPTO_WITH_CE ?= n
 24 CFG_WITH_STACK_CANARIES ?= y
 25 CFG_TEE_CORE_EMBED_INTERNAL_TESTS ?= y
 26 CFG_WITH_STACK_CANARIES ?= y
 27 CFG_WITH_STATS ?= y
 28
 29 arm32-platform-cflags += -Wno-error=cast-align
 30
 31 $(call force,CFG_CRYPTO_SHA256_ARM32_CE,n)
 32 $(call force,CFG_CRYPTO_SHA256_ARM64_CE,n)
 33 $(call force,CFG_CRYPTO_SHA1_ARM32_CE,n)
 34 $(call force,CFG_CRYPTO_SHA1_ARM64_CE,n)
 35 $(call force,CFG_CRYPTO_AES_ARM64_CE,n)
</code></pre>
<h2 id="系统启动">系统启动</h2>
<h3 id="stage1">stage1</h3>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdn.net/20170523113635511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></figure>
<p>TEEOS是静态链接的，链接脚本可以看core/arch/arm/plat-gx/kern.ld.S内容是#include &quot;../kernel/kern.ld.S&quot; 说明这个链接脚本最终调用core/arch/arm/kernel/kern.ld.S，函数入口是ENTRY(_start),链接地址是CFG_TEE_LOAD_ADDR&gt;。根据入口_start代码在core/arch/arm/kernel/generic_entry_a32.S。</p>
<pre><code class="language-C">   1. _start:跳转reset
   
   2. reset
   
      bootargs_entry//保存loader传递过来的参数
   
         // entry r1, saved r7: (ARMv7 standard bootarg #1)
         // entry r2, saved r6: device tree address, (ARMv7 standard bootarg #2)
         // entry r1, saved r5: non-secure entry address (ARMv7 bootarg #0)
   
      disable cache
      plat_cpu_reset_early//这里是弱符号，真正的实现在plat-gx/plat_init.S里面，进入secure world
   
        /*
        * Disallow NSec to mask FIQ [bit4: FW=0]
        * Allow NSec to manage Imprecise Abort [bit5: AW=1]
        * Imprecise Abort trapped to Abort Mode [bit3: EA=0]
        * In Sec world, FIQ trapped to FIQ Mode [bit2: FIQ=0]
        * IRQ always trapped to IRQ Mode [bit1: IRQ=0]
        * Secure World [bit0: NS=0]
        */
       
        /*
        * Mandated HW config loaded
        *
        * SCTLR = 0x00000000
        * ACTRL = 0x00000040
        * - core NOT booted in full SMP (FW bit0=0)
        * NSACR = 0x00000C00
        * - NSec cannot change ACTRL.SMP (NS_SMP bit18=0)
        * - NSec can use SIMD/VFP (CP10/CP11) (bit15:14=2b00, bit11:10=2b11)
        */
   3. Reset primary   
      1. copy代码到运行地址,清理bss
      2. plat_cpu_reset_late//初始化cpu频率，由具体平台main.c里面代码实现
      3. console_init//初始化串口
      4. inval_cache_vrange
      5. 配置mmu
   
   4. generic_boot_init_primary:调转stage2。
</code></pre>
<h3 id="stage2">stage2</h3>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdn.net/20170523114027645?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<p>stage2代码在core/arch/arm/kernel/generic_boot.c。</p>
<pre><code class="language-C">661 static void init_primary_helper(unsigned long pageable_part,
662 ▸       ▸       ▸       ▸       unsigned long nsec_entry, unsigned long fdt)
663 {//第二个参数是内核的地址，第三个参数是fdt地址。
664 ▸       /*
665 ▸       ┆* Mask asynchronous exceptions before switch to the thread vector
666 ▸       ┆* as the thread handler requires those to be masked while
667 ▸       ┆* executing with the temporary stack. The thread subsystem also
668 ▸       ┆* asserts that the foreign interrupts are blocked when using most of
669 ▸       ┆* its functions.
670 ▸       ┆*/
671 ▸       thread_set_exceptions(THREAD_EXCP_ALL);//设置运行哪些异常处理
672 ▸       init_vfp_sec();//初始化浮点运算单元
673 ▸       init_runtime(pageable_part);//初始化TEE运行用到的内存，初始化线程内存，malloc内存、TA内存
674
675 ▸       thread_init_primary(generic_boot_get_handlers());//初始化TEE线程栈，异常处理
676 ▸       thread_init_per_cpu();
677 ▸       init_sec_mon(nsec_entry);//设置好kernel地址等待tee完成启动之后跳转到这个地址
678 ▸       init_fdt(fdt);//初始化fdt
679 ▸       configure_console_from_dt(fdt);
680
681 ▸       IMSG(&quot;OP-TEE version: %s&quot;, core_v_str);
682 ▸       IMSG(&quot;OP-TEE NS:0x%lx, FTD:0x%lx\n&quot;, nsec_entry, fdt);
683
684 ▸       main_init_gic();//初始化gic中断控制器
685 ▸       init_vfp_nsec();//初始化非安全环境的vfp
686 ▸       if (init_teecore() != TEE_SUCCESS)//初始化share memory加上初始化其他initcall
687 ▸       ▸       panic();
688 ▸       DMSG(&quot;Primary CPU switching to normal world boot\n&quot;);
689 }
</code></pre>
<h3 id="服务">服务</h3>
<ol>
<li>service_init、initcall1</li>
</ol>
<ul>
<li>register_supplicant_user_ta：加载ta image</li>
<li>verify_pseudo_tas_conformance：校验optee os内部的ta的合法性</li>
<li>tee_cryp_init：crypto功能初始化</li>
<li>tee_se_manager_init：mutex初始化</li>
</ul>
<ol start="2">
<li>servcie_init_late、initcall2</li>
</ol>
<ul>
<li>tee_fs_init_key_manager： 安全存储key生成</li>
</ul>
<h3 id="驱动">驱动</h3>
<ol>
<li>driver_init、initcall3：芯片驱动模块初始化</li>
<li>driver_init_late、initcall4：自定义驱动device结构模块初始化</li>
</ol>
<pre><code class="language-C"> 16 #define tee_device_register(...) static const TEE_Device __head \
 17         __used __section(&quot;.device&quot;) = { __VA_ARGS__ }
</code></pre>
<h2 id="ta">TA</h2>
<h3 id="system">system</h3>
<pre><code class="language-C"> 62 #define pseudo_ta_register(...) static const struct pseudo_ta_head __head \
 63                         __used __section(&quot;ta_head_section&quot;) = { __VA_ARGS__ }
</code></pre>
<p>pseudo_ta_register定义了系统ta的到ta_head_section这个特殊的段里，在系统初始化的时候verify_pseudo_tas_conformance里面实现的初始化。</p>
<ul>
<li>gprof: core/arch/arm/pta/gprof.c</li>
<li>interrupt_tests.ta: core/arch/arm/pta/Iiterrupt_tests.c</li>
<li>stats.ta: core/arch/arm/pta/stats.c</li>
<li>se_api_self_tests.ta: core/arch/arm/pta/se_api_self_tests.c</li>
<li>socket: core/arch/arm/tee/pta_socket.c</li>
<li>invoke_tests.pta: core/arch/arm/pta/pta_invoke_test.c</li>
</ul>
<h3 id="sign">sign</h3>
<h1 id="ree">REE</h1>
<h2 id="用户">用户</h2>
<p>当CA接口处于userspace层面，整个调用过程需要经过kernel space层面， linux driver层面， Monitor态中断处理层面， TEE OS kernel层面， TEE的userspace层面（TA）。</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdn.net/20170511210145320" alt="img"></figure>
<h3 id="libteec">libteec</h3>
<p>libteec库是OP-TEE提供给用户在linux userspace层面调用的接口实现,libteec代码的具体实现存放在optee_client/libteec目录下，OP-TEE提供给linux端使用的接口源代码的实现存放在optee_client/libteec/src/tee_client_api.c</p>
<pre><code class="language-C">shenjch@vm:v1.9-dev/tee/optee_client/libteec&gt; tree
.
├── include
│   ├── linux
│   │   └── tee.h
│   └── teec_benchmark.h
├── Makefile
└── src
    ├── teec_benchmark.c
    ├── tee_client_api.c
    └── teec_trace.c
</code></pre>
<pre><code class="language-C">//初始化一个TEEC_Context变量，该变量用于CA和TEE之间建立联系。其中参数name是用来定义TEE的身份，如果该参数为NULL，则CA将会选择默认的TEE方案来建立联系
1. TEEC_Result TEEC_InitializeContext(const char *name, TEEC_Context *ctx)；
//释放一个已经被初始化过的类型为TEEC_Context变量，关闭CA与TEE之间的连接。在调用该函数之前必须确保打开的session已经被关闭了。
2. void TEEC_FinalizeContext(TEEC_Context *ctx)；
//打开一个CA与对应TA之间的一个session，该session用于该CA与对应TA之间的联系，该CA需要连接的TA是由UUID指定的。session具有不同的打开和连接方式，根据不同的打开和连接方式CA可以在执行打开session的时候传递数据给TA，以便TA对打开操作做出权限检查。
3. TEEC_Result TEEC_OpenSession(TEEC_Context *ctx, TEEC_Session *session,const TEEC_UUID *destination,uint32_t connection_method, const void *connection_data,TEEC_Operation *operation, uint32_t *ret_origin)；
//关闭已经被初始化的CA与对应TA之间的session，在调用该函数之前需要保证所有的command已经执行完毕。如果session为NULL,则不执行任何操作。
4. void TEEC_CloseSession(TEEC_Session *session)
//通过cmd_id和打开的session，来通知session对应的TA执行cmd_id指定的操作。
5. TEEC_Result TEEC_InvokeCommand(TEEC_Session *session, uint32_t cmd_id,TEEC_Operation *operation, uint32_t *error_origin)
//取消某个CA与TA之间的操作，该接口只能由除执行TEEC_OpenSession和TEEC_InvokeCommand的thread之外的其他thread进行调用，而在TA端或者TEE OS可以选着并不响应该请求。只有当operation中的started域被设置成0之后，该操作方可有效。
6. void TEEC_RequestCancellation(TEEC_Operation *operation)
//注册一块在CA端的内存作为CA与TA之间的共享内存。
7. TEEC_Result TEEC_RegisterSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
//注册一块在CA与TA之间的共享文件，在CA端会将文件的描述符fd传递給OP-TEE，其内容被存放到shm中。
8. TEEC_Result TEEC_RegisterSharedMemoryFileDescriptor(TEEC_Context *ctx,TEEC_SharedMemory *shm,int
 fd)
//分配一块共享内存，共享内存是由OP-TEE中分配的,OP-TEE分配了共享内存之后将会返回该内存块的fd给CA，CA将会将fd映射到系统内存，然后将地址保存到shm中。
9. TEEC_Result TEEC_AllocateSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
//释放已经被分配或者是注册过的共享内存。
10. void TEEC_ReleaseSharedMemory(TEEC_SharedMemory *shm)
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdn.net/20170611163138066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<ul>
<li>在libteec中调用open函数来打开/dev/tee0设备的时候，最终会调用到tee_fops中的open成员指定的函数指针tee_open。</li>
<li>当在libteec和tee_supplicant打开了对应的设备之后，如果需要release设备，则可以调用该设备的release来实现，在userspace层面调用完成之后，最终会调用到OP-TEE驱动的release成员变量tee_release。</li>
<li>在libteec中获取OP-TEE版本信息，创建和关闭session，调用TA，分配和注册共享内存和fd以及释放共享内存，接收来自OP-TEE的请求以及回复数据给OP-TEE都是通过ioctl来完成的。在libteec和tee_supplicant中通过带上对应的参数调用ioctl函数来实现对应的操作需求，最终会调用到OP-TEE驱动中file_operation结构体变量tee_fops变量中的tee_ioctl函数</li>
</ul>
<h3 id="tee-supplicant">tee-supplicant</h3>
<p>tee_supplicant的主要作用是使OP-TEE能够通过tee_supplicant来访问REE端文件系统中的资源，例如加载存放在文件系统中的TA镜像到TEE中，对REE端数据库的操作，对EMMC中RPMB分区的操作，提供socket通信等。 其源代码optee_client/tee-supplicant目录中。编译之后会生成一个名字为tee_supplicant的可执行文件，该可执行文件在REE启动的时候会作为一个后台程序被自动启动，而且常驻于系统中。</p>
<p>tee_supplicant可执行文件在Linux启动的时候会被作为后台程序启动。启动的动作存放在build/init.d.optee文件中，其内容如下：</p>
<pre><code class="language-shell">#!/bin/sh  
#  
# /etc/init.d/optee  
#  
# Start/stop tee-supplicant (OP-TEE normal world daemon)  
#  
case &quot;$1&quot; in  
    start)  
    if [ -e /bin/tee-supplicant -a -e /dev/teepriv0 ]; then  
        echo &quot;Starting tee-supplicant...&quot;  
        tee-supplicant&amp; #将tee_supplicat以后台方式启动  
        exit 0  
    else  
        echo &quot;tee-supplicant or TEE device not found&quot;  
        exit 1  
    fi  
  
        ;;  
    stop)  
    killall tee-supplicant  
    ;;  
    status)  
    cat /dev/teepriv0 2&gt;&amp;1 | grep -q &quot;Device or resource busy&quot; || not=&quot;not &quot;  
    echo &quot;tee-supplicant is ${not}active&quot;  
    ;;  
esac  
</code></pre>
<p>tee_supplicant启动后作为Linux中的一个后台程序运行，起到处理RPC请求 service的作用。通过类似于C/S的方式为OP-TEE提供对REE端文件系统的操作。该可执行文件的源代码的入口函数存放在optee_client/tee-supplicant/src/tee_supplicant.c文件中。</p>
<p>tee_supplicant中的loop循环</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdn.net/20170608121635411?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<p>加载TA image到共享内存，当TA请求的func ID为RPC_CMD_LOAD_TA时，tee_supplicant将会到文件系统中将TA镜像的内容读取到共享内存中。该操作是通过调用load_ta函数来实现的，该函数定义在tee_supplicant.c文件中</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdn.net/20170608141446987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<h2 id="驱动-2">驱动</h2>
<h3 id="加载">加载</h3>
<p>OP-TEE驱动主要作用是REE与TEE端进行数据交互的桥梁作用,tee_supplicant和libteec调用接口之后几乎都会首先通过系统调用陷入到kernel space，然后kernel根据传递的参数找到OP-TEE驱动，并命中驱动的operation结构体中的具体处理函数来完成实际的操作，对于OP-TEE驱动，一般都会触发SMC调用，并带参数进入到ARM cortex的monitor模式，在monitor模式中对执行normal world和secure world的切换，待状态切换完成之后，会将驱动端带入的参数传递給OP-TEE中的thread进行进一步的处理。OP-TEE驱动的源代码存放在linux/drivers/tee目录:</p>
<pre><code class="language-c">shenjch@vm:v1.9-dev/linux-4.4.25/drivers/tee&gt; tree .
.
├── Kconfig
├── Makefile
├── optee
│   ├── call.c
│   ├── core.c
│   ├── Kconfig
│   ├── Makefile
│   ├── optee_msg.h
│   ├── optee_private.h
│   ├── optee_smc.h
│   ├── rpc.c
│   └── supp.c
├── tee_core.c
├── tee_private.h
├── tee_shm.c
└── tee_shm_pool.c
</code></pre>
<p>OP-TEE驱动的加载过程分为两部分，第一部分是创建class和分配设备号，第二部分就是probe过程。在正式介绍之前首先需要明白两个linux kernel中加载驱动的函数：subsys_initcall和module_init函数。OP-TEE驱动的第一部分是调用subsys_initcall函数来实现，而第二部分则是调用module_init来实现。整个OP-TEE驱动的初始化流程图如下图所示:</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdn.net/20170608202139541?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<ul>
<li>tee_init函数初始化设备号和class,
<ul>
<li>linux/drivers/tee/tee_core.c</li>
</ul>
</li>
<li>optee_driver_init函数执行
<ul>
<li>/drivers/tee/optee/core.c</li>
</ul>
</li>
</ul>
<h3 id="tee设备数据结构">tee设备数据结构</h3>
<pre><code class="language-C">static const struct file_operations tee_fops = {  
    .owner = THIS_MODULE,   //驱动属于哪儿谁  
    .open = tee_open,   //驱动文件的open操作的具体实现的函数指针  
    .release = tee_release, //驱动文件的release操作的具体实现的函数指针  
    .unlocked_ioctl = tee_ioctl,    //驱动文件的ioctl操作的具体实现的函数指针  
    .compat_ioctl = tee_ioctl,   //驱动文件的ioctl操作的具体实现的函数指针，用户空间为32位，而内核为64位时使用  
};  

static struct tee_driver_ops optee_ops = {  
    .get_version = optee_get_version,   //获取OP-TEE版本信息的接口函数  
    .open = optee_open,  //打开/dev/tee0设备的具体实现，初始化列表和互斥体，返context  
    .release = optee_release, //释放掉打开的/dev/tee0设备资源，并通知secure world关闭session  
    .open_session = optee_open_session, //打开session，以便CA于TA进行交互  
    .close_session = optee_close_session, //关闭已经打开的session，断开CA与TA之间的交互  
    .invoke_func = optee_invoke_func,   //通过smc操作发送CA请求到对应TA  
    .cancel_req = optee_cancel_req, //取消CA端已经发送的smc请求  
};  
static struct tee_driver_ops optee_supp_ops = {  
    .get_version = optee_get_version,   //获取OP-TEE的版本信息  
    .open = optee_open, //打开/dev/teepriv0设备的具体实现  
    .release = optee_release, //释放掉打开的/dev/teepriv0设备，并通知secure world关闭session  
    .supp_recv = optee_supp_recv, //接收从OP-TEE发送给tee_supplicant的请求  
    .supp_send = optee_supp_send,  //执行完OP-TEE请求的操作后将结果和数据发送给OP-TEE  
};  
static struct dma_buf_ops tee_shm_dma_buf_ops = {  
    .map_dma_buf = tee_shm_op_map_dma_buf,  //暂未实现  
    .unmap_dma_buf = tee_shm_op_unmap_dma_buf,  //暂未实现  
    .release = tee_shm_op_release,  //释放掉指定的共享内存  
    .kmap_atomic = tee_shm_op_kmap_atomic, //暂未实现  
    .kmap = tee_shm_op_kmap,    //暂未实现  
    .mmap = tee_shm_op_mmap,    //dma共享内存进行地址映射  
};  
</code></pre>
<h1 id="模式切换">模式切换</h1>
<h2 id="中断向量表">中断向量表</h2>
<p>在一个完整的系统中都会存在中断，如果支持trustzone并且具有TEE的支持，则每个CPU将具有两个种状态：secure world, non-sercure world，通过write_scr的NS bit来切换secure world, non-sercure world，plat_cpu_reset_early进入secure world，.sm_ret_to_nsec返回non-sercure world。在ARM中secure world和non-secure world都具monitor模式，有独立的VBAR寄存器和中断向量表。而当CPU处于monitor态时，CPU将具有独立的中断向量表和MVBAR寄存器。而且在secure world态时需要使能FIQ的支持，而在non-secure world态时则需要禁止FIQ的支持。其在两种态之间的切换的时候需要做到对应的上下文的保存和恢复操作。</p>
<h3 id="vbar配置">VBAR配置</h3>
<p>在初始化阶段TEE的中断向量的加载和配置将会通过thread_init_vbar函数来实现，从初始化起始到配置中断向量表的整个调用过程如下：_start--&gt; b reset--&gt;b reset_primary--&gt;bl generic_boot_init_primary--&gt;init_primary_helper--&gt;thread_init_per_cpu—&gt;thread_init_vbar；thread_init_vbar函数为汇编代码内容如下，定义在optee_os_core/arch/arm/kernel/thread_a32.S文件中：</p>
<pre><code class="language-C">FUNC thread_init_vbar , :  
UNWIND( .fnstart)  
    /* Set vector (VBAR) */  
    ldr r0, =thread_vect_table  //将中断向量表的地址赋值给r0寄存器  
    write_vbar r0//将r0寄存器指定的地址中的内容写入到VBAR寄存器中来设定TEE的中断向量表  
    bx  lr  //跳转返回  
UNWIND( .fnend)  
END_FUNC thread_init_vbar  

LOCAL_FUNC thread_vect_table , :  
UNWIND( .fnstart)  
UNWIND( .cantunwind)  
    b   .           /* Reset            */  
    b   thread_und_handler  /* Undefined instruction    */  
    b   thread_svc_handler  /* System call          */  
    b   thread_pabort_handler   /* Prefetch abort       */  
    b   thread_dabort_handler   /* Data abort           */  
    b   .           /* Reserved         */  
    b   thread_irq_handler  /* IRQ              */  
    b   thread_fiq_handler  /* FIQ              */  
UNWIND( .fnend)  
END_FUNC thread_vect_table  
</code></pre>
<h3 id="mvbar配置">MVBAR配置</h3>
<p>在OP-TEE的启动的过程中，将会调用init_sec_mon函数来完成monitor态的相关初始化，该函数被定义在optee_os/core/arch/arm/kernel/thread.c文件中，从初始化的时候调用的流程如下：_start--&gt; b reset--&gt;b reset_primary--&gt;bl generic_boot_init_primary--&gt;init_primary_helper—&gt;init_sec_mon。该函数会调用sm_init来进行monitor的相关初始化，sm_init函数定义在optee_os/core/arch/arm/sm/sm_a32.S文件中,内容如下：</p>
<pre><code class="language-C">static void init_sec_mon(size_t pos __maybe_unused)  
{  
#if !defined(CFG_WITH_ARM_TRUSTED_FW)  
    /* Initialize secure monitor */  
/* 调用sm_init函数完成Monitor态的相关初始化 */  
    sm_init(GET_STACK(stack_tmp[pos]));  
#endif  
} 

/* void sm_init(vaddr_t stack_pointer); */  
FUNC sm_init , :  
UNWIND( .fnstart)  
    /* Set monitor stack */  
    mrs r1, cpsr    //设置monitor的栈  
    cps #CPSR_MODE_MON  
    /* Point just beyond sm_ctx.sec */  
    sub sp, r0, #(SM_CTX_SIZE - SM_CTX_NSEC)  
    msr cpsr, r1  
  
    /* Set monitor vector (MVBAR) */  
    ldr r0, =sm_vect_table  //获取monitor态的中断向量表变量  
    write_mvbar r0      //将中断向量表的地址写入到MVBAR寄存器中  
  
    bx  lr  
END_FUNC sm_init 

LOCAL_FUNC sm_vect_table , :  
UNWIND( .fnstart)  
UNWIND( .cantunwind)  
    b   .       /* Reset            */  
    b   .       /* Undefined instruction    */  
    b   sm_smc_entry    /* Secure monitor call */  
    b   .       /* Prefetch abort       */  
    b   .       /* Data abort           */  
    b   .       /* Reserved         */  
    b   .       /* IRQ              */  
    b   sm_fiq_entry    /* FIQ              */  
UNWIND( .fnend)  
END_FUNC sm_vect_table 
</code></pre>
<h3 id="fiq处理">FIQ处理</h3>
<p>在OP-TEE的启动的过程中，将会调用init_sec_mon函数来完成monitor态的相关初始化，该函数被定义在optee_os/core/arch/arm/kernel/thread.c文件中，从初始化的时候调用的流程如下：</p>
<p>_start--&gt; b reset--&gt;b reset_primary--&gt;bl generic_boot_init_primary--&gt;init_primary_helper--&gt;init_sec_mon</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdn.net/20170613153313684?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<h3 id="irq处理">IRQ处理</h3>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdn.net/20170528013655282?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<h2 id="monitor模式处理">monitor模式处理</h2>
<h3 id="secure-world">secure world</h3>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdn.net/20170528203118437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<h3 id="non-secure-world">non secure world</h3>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdn.net/20170528203445672?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<h2 id="linux到tee切换">linux到tee切换</h2>
<p>libteec和tee_supplicant调用接口之后最终会调用到OP-TEE驱动来触发对应的SMC操作。在OP-TEE驱动中触发SMC操作的方法是调用arm_smccc_smc(a0, a1, a2, a3, a4, a5, a6, a7, res)来实现，其中在REE端需要传递給TEE侧的数据被存放在a0~a7中。调用上述函数自后，CPU中的cortex就会切换到monitor模式，进入monitor模式之后首先会去获取MVBAR寄存器中存放的monitor模式的中断向量表地址，然后查找monitor模式中断向量表的sm_smc_entry函数来对请求进行处理。在sm_smc_entry中对当前SCR寄存器中的NS为来判定请求是来自于secure world还是normal world。如果请求来自于REE侧，则程序会执行smc_from_nsec分支完成SCR中NS的设置并调转到sm_from_nsec函数继续执行。该判定是通过判定r0寄存器中存放的数据中的第31个bit的值是1还是0，如果bit31的值是1，则表面该smc请求时快速smc(fast smc)，如果该值为0则是标准smc请求。</p>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdn.net/20170703175022801?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<p>在OP-TEE中用于处理各种来自外部或者的monitor模式请求的入口函数都存放在OP-TEE的线程向量表thread_vector_table中。该项量的实现在optee_os/core/arch/arm/kernel/thread_a32.S文件中</p>
<pre><code class="language-C">167 /*
168  * Vector table supplied to ARM Trusted Firmware (ARM-TF) at
169  * initialization.  Also used when compiled with the internal monitor, but
170  * the cpu_*_entry and system_*_entry are not used then.
171  *
172  * Note that ARM-TF depends on the layout of this vector table, any change
173  * in layout has to be synced with ARM-TF.
174  */
175 FUNC thread_vector_table , :
176 UNWIND( .fnstart)
177 UNWIND( .cantunwind)
178         b       vector_std_smc_entry
179         b       vector_fast_smc_entry
180         b       vector_cpu_on_entry
181         b       vector_cpu_off_entry
182         b       vector_cpu_resume_entry
183         b       vector_cpu_suspend_entry
184         b       vector_fiq_entry
185         b       vector_system_off_entry
186         b       vector_system_reset_entry
187 UNWIND( .fnend)
188 END_FUNC thread_vector_table
</code></pre>
<p>注意该线程向量表与OP-TEE的中断处理向量表thread_vect_table是不一样的。thread_vector_table 属于线程级别，会被monitor模式或者其他中断处理函数调用到，而thread_vect_table才是OP-TEE存放在VBAR寄存器中的中断向量表。当在secure world状态下产生了FIQ事件时，将会调用中断向量表thread_vect_table中的FIQ中断处理函数，然后才会调用到thread_vector_table中给的vector_fiq_entry来执行FIQ的后续处理。</p>
<pre><code>tee_entry_std（get_cmd_buffer这里将shm共享内存的物理地址专为虚拟地址，这个ree通过smc传递过来的参数存放地址物理空间4k在ree预留）-&gt;entry_invoke_command（copy_in_params）-&gt;tee_ta_invoke_command-&gt;res = sess-&gt;ctx-&gt;ops-&gt;enter_invoke_cmd(sess, cmd, param, err);-&gt;user_ta_enter_invoke_cmd-&gt;user_ta_enter(tee_mmu_map_param将shm的物理地址专为ta的虚拟地址)-&gt;thread_enter_user_mode(utc-&gt;entry_func, utc-&gt;is_32bit,根据自己的uuid找到自己的接口)-&gt;.entry.ptr32 = { .lo = (uint32_t)__utee_entry },-&gt;__utee_entry-&gt;entry_invoke_command-&gt;TA_InvokeCommandEntryPoint
</code></pre>
<h3 id="fast-smc">fast smc</h3>
<pre><code class="language-C">LOCAL_FUNC vector_fast_smc_entry , :  
UNWIND( .fnstart)  
UNWIND( .cantunwind)  
    push    {r0-r7} //将r0~r7入栈  
    mov r0, sp  //将栈地址赋值给r0  
    bl  thread_handle_fast_smc  //调用thread_handle_fast_smc进行处理，参数为r0中的数据  
    pop {r1-r8} //处理完成之后，执行出栈操作  
    ldr r0, =TEESMC_OPTEED_RETURN_CALL_DONE     //r0存放fast smc处理操作的结果  
    smc #0  //触发smc请求 切换到monitor模式，返回normal world中  
    b   .   /* SMC should not return */  
UNWIND( .fnend)  
END_FUNC vector_fast_smc_entry  
  
void thread_handle_fast_smc(struct thread_smc_args *args)  
{  
/* 使用canaries原理检查栈空间是否存在溢出或者被破坏 */  
    thread_check_canaries();  
  
/* 调用thread_fast_smc_handler_ptr处理smc请求 */  
    thread_fast_smc_handler_ptr(args);  
    /* Fast handlers must not unmask any exceptions */  
    assert(thread_get_exceptions() == THREAD_EXCP_ALL);  
}  

void tee_entry_fast(struct thread_smc_args *args)  
{  
    switch (args-&gt;a0) {  
  
    /* Generic functions */  
/* 获取API被调用的次数，可以根据实际需求实现 */  
    case OPTEE_SMC_CALLS_COUNT:  
        tee_entry_get_api_call_count(args);  
        break;  
/* 获取OP-TEE API的UID值 */  
    case OPTEE_SMC_CALLS_UID:  
        tee_entry_get_api_uuid(args);  
        break;  
/* 获取OP-TEE中API的版本信息 */  
    case OPTEE_SMC_CALLS_REVISION:  
        tee_entry_get_api_revision(args);  
        break;  
/* 获取OP-TEE OS的UID值 */  
    case OPTEE_SMC_CALL_GET_OS_UUID:  
        tee_entry_get_os_uuid(args);  
        break;  
/* 获取OS的版本信息 */  
    case OPTEE_SMC_CALL_GET_OS_REVISION:  
        tee_entry_get_os_revision(args);  
        break;  
  
    /* OP-TEE specific SMC functions */  
/* 获取OP-TEE与驱动之间的共享内存配置信息 */  
    case OPTEE_SMC_GET_SHM_CONFIG:  
        tee_entry_get_shm_config(args);  
        break;  
/* 获取I2CC的互斥体信息 */  
    case OPTEE_SMC_L2CC_MUTEX:  
        tee_entry_fastcall_l2cc_mutex(args);  
        break;  
/* OP-TEE的capabilities信息 */  
    case OPTEE_SMC_EXCHANGE_CAPABILITIES:  
        tee_entry_exchange_capabilities(args);  
        break;  
/* 关闭OP-TEE与驱动的共享内存的cache */  
    case OPTEE_SMC_DISABLE_SHM_CACHE:  
        tee_entry_disable_shm_cache(args);  
        break;  
/* 使能OP-TEE与驱动之间共享内存的cache */  
    case OPTEE_SMC_ENABLE_SHM_CACHE:  
        tee_entry_enable_shm_cache(args);  
        break;  
/* 启动其他cortex的被使用 */  
    case OPTEE_SMC_BOOT_SECONDARY:  
        tee_entry_boot_secondary(args);  
        break;  
  
    default:  
        args-&gt;a0 = OPTEE_SMC_RETURN_UNKNOWN_FUNCTION;  
        break;  
    }  
} 
</code></pre>
<h3 id="std-smc">std smc</h3>
<pre><code class="language-C">LOCAL_FUNC vector_std_smc_entry , :  
UNWIND( .fnstart)  
UNWIND( .cantunwind)  
    push    {r0-r7} //将参数入栈  
    mov r0, sp  //将栈指针赋值给r0寄存器  
    bl  thread_handle_std_smc   //调用处理函数，参数的地址存放在r0寄存器中  
    /* 
     * Normally thread_handle_std_smc() should return via 
     * thread_exit(), thread_rpc(), but if thread_handle_std_smc() 
     * hasn't switched stack (error detected) it will do a normal &quot;C&quot; 
     * return. 
     */  
    pop {r1-r8} //出栈操作  
    ldr r0, =TEESMC_OPTEED_RETURN_CALL_DONE //标记OP-TEE处理完成  
    smc #0  //调用smc切回到normal world  
    b   .   /* SMC should not return */  
UNWIND( .fnend)  
END_FUNC vector_std_smc_entry 

void thread_handle_std_smc(struct thread_smc_args *args)
{
        thread_check_canaries();


        if (args-&gt;a0 == OPTEE_SMC_CALL_RETURN_FROM_RPC)
                thread_resume_from_rpc(args);
        else
               thread_alloc_and_run(args);

}

static void thread_alloc_and_run(struct thread_smc_args *args)
{
        
        init_regs(threads + n, args);

        
}

static void init_regs(struct thread_ctx *thread,
                struct thread_smc_args *args)
{
        thread-&gt;regs.pc = (uint32_t)thread_std_smc_entry;
}

void __weak __thread_std_smc_entry(struct thread_smc_args *args)
{

        thread_std_smc_handler_ptr(args);

     thread_std_smc_handler_ptr = handlers-&gt;std_smc;
}

void __weak tee_entry_std(struct thread_smc_args *smc_args)
{
 arg = mobj_get_va(mobj, 0);
        assert(arg &amp;&amp; mobj_is_nonsec(mobj));

        /* Enable foreign interrupts for STD calls */
        thread_set_foreign_intr(true);
        switch (arg-&gt;cmd) {
        case OPTEE_MSG_CMD_OPEN_SESSION:
                entry_open_session(smc_args, arg, num_params);
                break;
        case OPTEE_MSG_CMD_CLOSE_SESSION:
                entry_close_session(smc_args, arg, num_params);
                break;
        case OPTEE_MSG_CMD_INVOKE_COMMAND:
                entry_invoke_command(smc_args, arg, num_params);
                break;
        case OPTEE_MSG_CMD_CANCEL:
                entry_cancel(smc_args, arg, num_params);
                break;
        case OPTEE_MSG_CMD_REGISTER_SHM:
                register_shm(smc_args, arg, num_params);
                break;
        case OPTEE_MSG_CMD_UNREGISTER_SHM:
                unregister_shm(smc_args, arg, num_params);
                break;

        default:
                EMSG(&quot;Unknown cmd 0x%x&quot;, arg-&gt;cmd);
                smc_args-&gt;a0 = OPTEE_SMC_RETURN_EBADCMD;
        }
        mobj_free(mobj);
}
</code></pre>
<h1 id="ta开发">TA开发</h1>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdn.net/20170510115636564?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2h1YWlmZW5neXVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></figure>
<h1 id="内存">内存</h1>
<p>安全空间28M，非安全空间4M，安全空间分为TEE_RAM和TA_RAM，非安全空间SHMEM。core/arch/arm/plat-gx/platform_config.h</p>
<pre><code>/*
 * TEE/TZ DRAM layout:
 *
 *  +---------------------------------------+  &lt;- TEE_RAM_START   = TZDRAM_BASE(内存尾部32MB)
 *  | TEE private secure |  TEE_RAM          |  ^
 *  |   external memory  |                  |   v + 4MB
 *  +---------------------------------------+  &lt;- TA_RAM_START    = TZDRAM_BASE + 4MB
 *  | TEE private secure |  TA_RAM          |   ^
 *  |   external memory  |                  |   v + 24MB
 *  +---------------------------------------+  &lt;- TEE_SHMEM_START = TZDRAM_BASE + 4MB + 24MB
 *  |     Non secure     |  SHM             |   |
 *  |   shared memory    |                  |   |  + 4MB
 *  +---------------------------------------+   v
 *
 *  TEE_RAM : 4  MB
 *  TA_RAM  : 24 MB
 *  SHM_RAM : 4  MB
 */

</code></pre>
<h3 id="内存类型">内存类型</h3>
<h3 id="mmu初始化和映射表">MMU初始化和映射表</h3>
<p>MMU初始化函数 core_init_mmu_map在文件core/arch/arm/mm/core_mmu.c。</p>
<pre><code>void core_init_mmu_map(void)
{
        struct tee_mmap_region *map;
        size_t n;

        for (n = 0; n &lt; ARRAY_SIZE(secure_only); n++) {
                if (pbuf_intersects(nsec_shared, secure_only[n].paddr,
                                    secure_only[n].size))
                        panic(&quot;Invalid memory access config: sec/nsec&quot;);
        }
        //检查安全空间和非安全空间是否重合，具体分配看core/arch/arm/plat-gx/platform_config.h
        
        /*
        static struct memaccess_area secure_only[] __nex_data = {
        MEMACCESS_AREA(TZDRAM_BASE, TZDRAM_SIZE),
};

static struct memaccess_area nsec_shared[] __nex_data = {
        MEMACCESS_AREA(TEE_SHMEM_START, TEE_SHMEM_SIZE),
};

        */

        COMPILE_TIME_ASSERT(CFG_MMAP_REGIONS &gt;= 13);
        init_mem_map(static_memory_map, ARRAY_SIZE(static_memory_map));

        map = static_memory_map;
        while (!core_mmap_is_end_of_table(map)) {
                switch (map-&gt;type) {
                case MEM_AREA_TEE_RAM:
                case MEM_AREA_TEE_RAM_RX:
                case MEM_AREA_TEE_RAM_RO:
                case MEM_AREA_TEE_RAM_RW:
                case MEM_AREA_NEX_RAM_RW:
                        if (!pbuf_is_inside(secure_only, map-&gt;pa, map-&gt;size))
                                panic(&quot;TEE_RAM can't fit in secure_only&quot;);
                        break;
                case MEM_AREA_TA_RAM:
                        if (!pbuf_is_inside(secure_only, map-&gt;pa, map-&gt;size))
                                panic(&quot;TA_RAM can't fit in secure_only&quot;);
                        break;
                case MEM_AREA_NSEC_SHM:
                        if (!pbuf_is_inside(nsec_shared, map-&gt;pa, map-&gt;size))
                                panic(&quot;NS_SHM can't fit in nsec_shared&quot;);
                        break;
                case MEM_AREA_SEC_RAM_OVERALL:
                case MEM_AREA_TEE_COHERENT:
                case MEM_AREA_TEE_ASAN:
                case MEM_AREA_IO_SEC:
                case MEM_AREA_IO_NSEC:
                case MEM_AREA_RAM_SEC:
                case MEM_AREA_RAM_NSEC:
                case MEM_AREA_RES_VASPACE:
                case MEM_AREA_SHM_VASPACE:
                case MEM_AREA_PAGER_VASPACE:
                        break;
                default:
                        EMSG(&quot;Uhandled memtype %d&quot;, map-&gt;type);
                        panic();
                }
                                }
                map++;
        }

        core_init_mmu(static_memory_map);
        dump_xlat_table(0x0, 1);
}
</code></pre>
<pre><code>static void init_mem_map(struct tee_mmap_region *memory_map, size_t num_elems)
{
        const struct core_mmu_phys_mem *mem;
        struct tee_mmap_region *map;
        size_t last = 0;
        size_t __maybe_unused count = 0;
        vaddr_t va;
        vaddr_t end;
        bool __maybe_unused va_is_secure = true; /* any init value fits */
//这里需要注意，总共现在memory_map最大是64个控制块，如果register_mem太多这里会出错。
        for (mem = phys_mem_map_begin; mem &lt; phys_mem_map_end; mem++) {
                struct core_mmu_phys_mem m = *mem;

                /* Discard null size entries */
                if (!m.size)
                        continue;

                /* Only unmapped virtual range may have a null phys addr */
                assert(m.addr || !core_mmu_type_to_attr(m.type));

#if 1
                if (m.type == MEM_AREA_IO_NSEC || m.type == MEM_AREA_IO_SEC) {
                        m.addr = ROUNDDOWN(m.addr, SMALL_PAGE_SIZE);
                        m.size = ROUNDUP(m.size + (mem-&gt;addr - m.addr), SMALL_PAGE_SIZE);
                }
#endif
                add_phys_mem(memory_map, num_elems, &amp;m, &amp;last);
        }
}
</code></pre>
<pre><code>dump_mmap_table
</code></pre>
<pre><code>这个函数是设置共享内存的，两个区域，ree和tee的共享内存，tee的内核态和用户态共享内存。
static TEE_Result default_mobj_init(void)
{
        shm_mobj = mobj_phys_alloc(default_nsec_shm_paddr,
                                   default_nsec_shm_size, SHM_CACHE_ATTRS,
                                   CORE_MEM_NSEC_SHM);
        if (!shm_mobj)
                panic(&quot;Failed to register shared memory&quot;);

#ifdef CFG_SECURE_DATA_PATH
        sdp_mem_mobjs = core_sdp_mem_create_mobjs();
        if (!sdp_mem_mobjs)
                panic(&quot;Failed to register SDP memory&quot;);
#endif

        return TEE_SUCCESS;
}

driver_init_late(default_mobj_init);


static TEE_Result alloc_temp_sec_mem(size_t size, struct mobj **mobj,
                                     uint8_t **va)
{
        /* Allocate section in secure DDR */
#ifdef CFG_PAGED_USER_TA
        *mobj = mobj_seccpy_shm_alloc(size);
#else
        *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &amp;tee_mm_sec_ddr);
#endif
        if (!*mobj)
                return TEE_ERROR_GENERIC;

        *va = mobj_get_va(*mobj, 0);
        return TEE_SUCCESS;
}
</code></pre>

            </div>
          </article>
        </div>

        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://jaycamu.github.io/x-knowledge//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
